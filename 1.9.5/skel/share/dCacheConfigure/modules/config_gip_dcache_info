# Written by Owen Synge for the dCache project

#/opt/d-cache/etc/glue-1.3.xml.template
#/opt/d-cache/libexec/infoprovidercms.rb -i

config_gip_dcache_helper_cms_app()
{
  RET=/opt/d-cache/libexec/infoprovidercms.rb
}



config_gip_dcache_helper_cms_app_input()
{
  yaimlog DEBUG "function config_gip_dcache_helper_cms_app_input start"

  if [ "X$RESET_DCACHE_CONFIGURATION" == Xyes ] ; then
    RET="/opt/d-cache/etc/glue-1.3.xml.template"
    if [ ! -f "${RET}" ] ; then
      RET=""
    fi
  else
    config_gip_dcache_helper_cms_app_output
    # Note returns $RET in same way as this function so no need.
  fi
  yaimlog DEBUG "function config_gip_dcache_helper_cms_app_input stop"
}

config_gip_dcache_helper_cms_app_output()
{
  yaimlog DEBUG "function config_gip_dcache_helper_cms_app_output start"
  RET="/opt/d-cache/etc/glue-1.3.xml"
  yaimlog DEBUG "function config_gip_dcache_helper_cms_app_output stop"
}


config_gip_dcache_info_get_GlueSiteName()
{
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSiteName start"
  if [ "X" != "X${SITE_NAME}" ] ; then
    RET="${SITE_NAME}"
  else
    RET="mysitename"
  fi
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSiteName stop"
}


config_gip_dcache_info_get_GlueSEName()
{
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEName start"
  if [ "X" != "X${DCACHE_GLUE_SENAME}" ] ; then
    RET="$DCACHE_GLUE_SENAME"
  else
    RET="dcache@${DCACHE_ADMIN}:SRM"
  fi
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEName stop"
}

config_gip_dcache_info_get_GlueSEUniqueID()
{
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEUniqueID start"
  if [ "X" != "X${DCACHE_GLUE_SENAME}" ] ; then
    RET="$DCACHE_GLUE_SENAME"
  else
    RET="${DCACHE_ADMIN}"
  fi
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEUniqueID stop"
}

config_gip_dcache_info_get_GlueSEStatus()
{
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEStatus start"
  if [ "X" != "X${DCACHE_GLUE_SESTATUS}" ] ; then
    RET="$DCACHE_GLUE_SESTATUS"
  else
    RET="Production"
  fi
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEStatus stop"
}

config_gip_dcache_info_get_GlueSEArchitecture()
{
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEArchitecture start"
  if [ "X" != "X${DCACHE_GLUE_SEARCHITECTURE}" ] ; then
    RET="${DCACHE_GLUE_SEARCHITECTURE}"
  else
    RET="disk"
  fi
  yaimlog DEBUG "function config_gip_dcache_info_get_GlueSEArchitecture stop"
}



config_gip_dcache_info_setup()
{
  yaimlog DEBUG "function config_gip_dcache_info_setup start"
  local helperApp
  local input
  local output
  local file2update
  local siteUniqueId
  local seUniqueId
  local seName
  local dcacheStatus
  local dcacheArchitecture
  local nameSpacePrefix
  local unit2path
  local unit2vo
  local vo2path

  config_gip_dcache_helper_cms_app
  helperApp=${RET}
  config_gip_dcache_helper_cms_app_input
  input=${RET}
  config_gip_dcache_helper_cms_app_output
  output=${RET}
  if [ -z "${helperApp}" ] ; then
    yaimlog ERROR "Information system helper script was not found."
    return 1
  fi
  if [ -z "${input}" ] ; then
    yaimlog ERROR "Template input file '${input}' is not specified."
    return 1
  fi
  if [ -z "${output}" ] ; then
    yaimlog ERROR "Template output file '${output}' is not specified."
    return 1
  fi
  if [ ! -f "${input}" ] ; then
    yaimlog ERROR "Template output file '${input}' is missing."
    yaimlog INFO "You need to set \$RESET_DCACHE_CONFIGURATION to 'yes' in your 'site-info.def'."
    yaimlog INFO "or copy the template file to '${input}'."
    return 1
  fi
  if [ ! -f "${output}" ] ; then
    cp ${input} ${output}
    yaimlog INFO "Making new '${output}' file."
  fi
  yaim_config_file_update_prepare ${output}
  file2update=$RET
  config_gip_dcache_info_get_GlueSiteName
  siteUniqueId="${RET}"

  config_gip_dcache_info_get_GlueSEUniqueID
  seUniqueId="${RET}"

  config_gip_dcache_info_get_GlueSEName
  seName="${RET}"

  config_gip_dcache_info_get_GlueSEStatus
  dcacheStatus="${RET}"

  config_gip_dcache_info_get_GlueSEArchitecture
  dcacheArchitecture="${RET}"

  config_dcache_chimera_vo_dir_get
  nameSpacePrefix="${RET}"

  # Now generate the command line

  CMD="${helperApp} --input ${input} --output ${file2update} "
  supportedVos=""
  unit2path=""
  unit2vo=""
  vo2path=""
  # Now process each VO
  for Thisvo in ${VOS} ; do
    if [ "X" != "X${supportedVos}" ] ; then
      supportedVos="${Thisvo},${supportedVos}"
    else
      supportedVos="${Thisvo}"
    fi
    if [ "X" != "X${nameSpacePrefix}" ] ; then
      local addedunit2path
      local addedunit2vo
      local addedvo2path
      addedunit2path="${Thisvo}:STATIC@osm^${nameSpacePrefix}/${Thisvo},${Thisvo}:GENERATED@osm^${nameSpacePrefix}/${Thisvo}/generated"
      addedunit2vo="${Thisvo}:STATIC@osm^${Thisvo},${Thisvo}:GENERATED@osm^${Thisvo}"
      addedvo2path="${Thisvo}^${nameSpacePrefix}/${Thisvo}"
      if [ "X" != "X${unit2path}" ] ; then
        unit2path="${unit2path},${addedunit2path}"
      else
        unit2path="${addedunit2path}"
      fi
      if [ "X" != "X${unit2vo}" ] ; then
        unit2vo="${unit2vo},${addedunit2vo}"
      else
        unit2vo="${addedunit2vo}"
      fi
      if [ "X" != "X${vo2path}" ] ; then
        vo2path="${vo2path},${addedvo2path}"
      else
        vo2path="${addedvo2path}"
      fi
    fi
  done # end process each VO
  if [ "X" != "X${supportedVos}" ] ; then
    CMD="$CMD --vos ${supportedVos} "
  fi
  if [ "X" != "X${siteUniqueId}" ] ; then
    CMD="$CMD --site-unique-id ${siteUniqueId} "
  fi
  if [ "X" != "X${seUniqueId}" ] ; then
    CMD="$CMD --se-unique-id ${seUniqueId} "
  fi
  if [ "X" != "X${seName}" ] ; then
    CMD="$CMD --se-name ${seName} "
  fi
  if [ "X" != "X${dcacheStatus}" ] ; then
    CMD="$CMD --dcache-status ${dcacheStatus} "
  fi
  if [ "X" != "X${dcacheArchitecture}" ] ; then
    CMD="$CMD --dcache-architecture ${dcacheArchitecture} "
  fi
  if [ "X" != "X${nameSpacePrefix}" ] ; then
    CMD="$CMD --name-space-prefix ${nameSpacePrefix} "
  fi
  if [ "X" != "X${unit2path}" ] ; then
    CMD="$CMD --unit2path ${unit2path} "
  fi
  if [ "X" != "X${unit2vo}" ] ; then
    CMD="$CMD --unit2vo ${unit2vo} "
  fi
  if [ "X" != "X${vo2path}" ] ; then
    CMD="$CMD --vo2path ${vo2path} "
  fi
  yaimlog DEBUG "To generate the information systems configuration running $CMD"
  $CMD
  cmdrc=$?
  if [ "${cmdrc}" != "0" ] ; then
    yaimlog ERROR "Command ${CMD} failed please rerun it to find out why."
    yaimlog WARNING "Giving up configuring the information system"
    return 1
  fi
  if [ "${file2update}" != "${output}" ] ; then
    yaim_config_file_update_done ${output}
    if [ $? == 1 ] ; then
      yaimlog WARNING "Changed the file ${output}"
    fi
  fi

  yaimlog DEBUG "function config_gip_dcache_info_setup stop"
  return 0
}


config_gip_dcache_info_link_src()
{
  yaimlog DEBUG "function config_gip_dcache_info_link_src start"
  RET="/opt/d-cache/libexec/infoProvider/info-based-infoProvider.sh"
  yaimlog DEBUG "function config_gip_dcache_info_link_src stop"
}


config_gip_dcache_info_link_target()
{
  yaimlog DEBUG "function config_gip_dcache_info_link_target start"
  RET="/opt/glite/etc/gip/provider/info-based-infoProvider.sh"
  yaimlog DEBUG "function config_gip_dcache_info_link_target stop"
}


config_gip_dcache_info_break_old()
{
  local symlinkdir
  yaimlog DEBUG "function config_gip_dcache_info_break_old start"
  symlinkdir="/opt/glite/etc/gip/provider"
  config_gip_dcache_info_link_target
  target=${RET}
  # Now delete all links in the directory except the target
  for file in `ls ${symlinkdir}`
  do
    if [ -s ${symlinkdir}/${file} ] ; then
      if [ "${target}" != "${symlinkdir}/${file}" ] ; then
        yaimlog INFO "Deleting file ${target}"
        rm ${target}
      fi
    fi
  done
  yaimlog DEBUG "function config_gip_dcache_info_break_old stop"
}


config_gip_dcache_info_link()
{
  local linksrc
  local linktarget
  yaimlog DEBUG "function config_gip_dcache_info_link start"
  config_gip_dcache_info_link_src
  linksrc=$RET
  config_gip_dcache_info_link_target
  linktarget=$RET
  if [ ! -f "${linksrc}" ] ; then
    yaimlog WARNING "The file ${linksrc} does not exist."
    return 1
  fi
  if [ ! -s "${linktarget}" ] ; then
    yaimlog INFO "Making Symbolic link ${linksrc} ${linktarget}"
    ln -s ${linksrc} ${linktarget}
  else
    yaimlog INFO "Symbolic link ${linksrc} ${linktarget} already exists."
  fi
  yaimlog DEBUG "function config_gip_dcache_info_link stop"
}


config_gip_dcache_info_check()
{
  rcdcache_info_check=$?
  if [ "${rcdcache_info_check}" != "0" ] ; then
    config_gip_check_users_exist
  fi
  return 0
}


config_gip_dcache_info_run()
{
  local rcisvd
  local rcdcache_info_check
  local infosetuprc
  local giponlyrc
  local bdiionlyrc
  yaimlog DEBUG "function config_gip_dcache_info_run start"
  config_gip_dcache_info_check
  rcdcache_info_check=$?
  if [ "${rcdcache_info_check}" != "0" ] ; then
    yaimlog INFO "Information system is not needed here."
    return 0
  fi
  config_gip_only
  giponlyrc=$?
  if [ "${giponlyrc}" != "0" ] ; then
    yaimlog ERROR "function config_gip_only returned the ${giponlyrc} error code"
    return ${giponlyrc}
  fi
  config_bdii_only
  bdiionlyrc=$?
  if [ "${bdiionlyrc}" != "0" ] ; then
    yaimlog ERROR "function config_bdii_only returned the ${bdiionlyrc} error code"
    return ${bdiionlyrc}
  fi
  yaim_query_conf_infoprovider_system
  rcisvd=$?
  if [ "${rcisvd}" == "1" ] ; then
    config_gip_dcache_info_setup
    infosetuprc=$?
    if [ "${infosetuprc}" != "0" ] ; then
      return 1
    fi
    config_gip_dcache_info_break_old
    infosetuprc=$?
    if [ "${infosetuprc}" != "0" ] ; then
      return 1
    fi
    config_gip_dcache_info_link
    infosetuprc=$?
    if [ "${infosetuprc}" != "0" ] ; then
      return 1
    fi
  fi
  yaimlog DEBUG "function config_gip_dcache_info_run stop"
  return 0
}

config_gip_dcache_info()
{
  return 0
}
