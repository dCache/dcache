<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
              http://www.springframework.org/schema/beans/spring-beans.xsd
              http://www.springframework.org/schema/context
              http://www.springframework.org/schema/context/spring-context.xsd">

  <context:annotation-config/>

  <!--
    Note that we have a three-node circular dependency with the
    following beans referencing each other:

        config   references  storage,
        storage  references  srm,
        srm      references  config.

    However, the "srm" bean's requirement on "config" is stronger: not
    only must "config" exists, but also that it has been configured
    with the "storage" bean.  This is because the SRM will fetch the
    AbstractStorageElement object from Configuration, decorate it and
    replace Configuration with the decorated object.

    Therefore, we must ensure that the following events happen in this
    order:

        1. "storage" bean is created,
        2. "config" bean is created,
        3. "config" bean is configured with the "storage" bean,
        4. "srm" bean is created.

    Spring does not complain about this circular dependency.  It will
    create objects and initialise them in an undocumented ordering,
    which seems to depend on where within the XML file the bean is
    described.

    To avoid this abitrary behaviour, the Spring 'depends-on'
    attribute is used to make the ordering explicit:

        srm     depends-on  config,
        config  depends-on  storage.
  -->

  <bean id="properties" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    <description>Imported configuration data</description>
    <property name="location" value="arguments:"/>
  </bean>

  <!-- Convert properties with multiple values separated by comma into an array of strings:
       key=value1,value2,value3 : String[] {value1, value2, value3}
    -->
  <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="customEditors">
      <map>
        <entry key="java.lang.String[]"
               value="org.springframework.beans.propertyeditors.StringArrayPropertyEditor"/>
      </map>
    </property>
  </bean>

  <bean id="pool-manager-stub" class="org.dcache.cells.CellStub">
    <description>Pool manager communication stub</description>
    <property name="destination" value="${srm.service.poolmanager}"/>
    <property name="timeout" value="${srm.service.poolmanager.timeout}"/>
    <property name="timeoutUnit" value="${srm.service.poolmanager.timeout.unit}"/>
  </bean>

  <bean id="gplazma-stub" class="org.dcache.cells.CellStub">
    <description>gPlazma communication stub</description>
    <property name="destination" value="${srm.service.gplazma}"/>
    <property name="timeout" value="${srm.service.gplazma.timeout}" />
    <property name="timeoutUnit" value="${srm.service.gplazma.timeout.unit}" />
  </bean>

  <bean id="space-manager-stub" class="org.dcache.cells.CellStub">
    <description>Space manager communication stub</description>
    <property name="destination" value="${srm.service.spacemanager}" />
    <property name="timeout" value="${srm.service.spacemanager.timeout}"  />
    <property name="timeoutUnit" value="${srm.service.spacemanager.timeout.unit}"  />
  </bean>

  <bean id="transfer-manager-stub" class="org.dcache.cells.CellStub">
    <description>Transfer manager communication stub</description>
    <property name="destination" value="${srm.service.transfermanager}" />
    <property name="timeout" value="${srm.service.transfermanager.timeout}" />
    <property name="timeoutUnit" value="${srm.service.transfermanager.timeout.unit}" />
  </bean>

  <bean id="copy-manager-stub" class="org.dcache.cells.CellStub">
    <description>Copy manager communication stub</description>
    <property name="destination" value="${srm.service.copymanager}" />
    <property name="timeout" value="${srm.service.copymanager.timeout}" />
    <property name="timeoutUnit" value="${srm.service.copymanager.timeout.unit}" />
  </bean>

  <bean id="pin-manager-stub" class="org.dcache.cells.CellStub">
    <description>Pin manager communication stub</description>
    <property name="destination" value="${srm.service.pinmanager}" />
    <property name="timeout" value="${srm.service.pinmanager.timeout}" />
    <property name="timeoutUnit" value="${srm.service.pinmanager.timeout.unit}" />
  </bean>

  <bean id="login-broker-stub" class="org.dcache.cells.CellStub">
    <description>Login broker communication stub</description>
    <property name="destination" value="${srm.protocols.loginbroker}"/>
    <property name="timeout" value="${srm.protocols.loginbroker.timeout}" />
    <property name="timeoutUnit" value="${srm.protocols.loginbroker.timeout.unit}" />
  </bean>

  <bean id="pnfs-stub" class="org.dcache.cells.CellStub">
    <description>PNFS manager communication stub</description>
    <property name="destination" value="${srm.service.pnfsmanager}"/>
    <property name="timeout" value="${srm.service.pnfsmanager.timeout}"/>
    <property name="timeoutUnit" value="${srm.service.pnfsmanager.timeout.unit}"/>
    <property name="retryOnNoRouteToCell" value="true"/>
  </bean>

  <bean id="pnfs" class="diskCacheV111.util.PnfsHandler">
    <description>PNFS manager client module</description>
    <constructor-arg ref="pnfs-stub"/>
  </bean>

  <bean id="list-handler" class="org.dcache.util.list.ListDirectoryHandler">
    <description>Client stub for directory listing</description>
    <constructor-arg ref="pnfs"/>
  </bean>

  <bean id="lb" class="org.dcache.util.LoginBrokerHandler"
        init-method="start"
        destroy-method="stop">
    <description>Registers the door with a LoginBroker</description>
    <property name="executor">
      <bean class="java.util.concurrent.Executors"
            factory-method="newSingleThreadScheduledExecutor"
            destroy-method="shutdown">
        <description>Thread pool for scheduled activities</description>
      </bean>
    </property>
    <property name="updateTime" value="${srm.service.loginbroker.update-period}"/>
    <property name="updateTimeUnit" value="${srm.service.loginbroker.update-period.unit}"/>
    <property name="updateThreshold" value="${srm.service.loginbroker.update-threshold}"/>
    <property name="protocolEngine" value="diskCacheV111.srm.dcache.Storage"/>
    <property name="protocolVersion" value="${srm.service.loginbroker.version}"/>
    <property name="protocolFamily" value="${srm.service.loginbroker.family}"/>
    <property name="address" value="#{ '${srm.net.listen}'.equals('any') ? null : '${srm.net.listen}' }"/>
    <property name="port" value="${srm.net.port}"/>
    <property name="loginBrokers" value="${srm.service.loginbroker}"/>
  </bean>

  <bean id="auth-persistence-manager" class="diskCacheV111.srm.dcache.DcacheUserPersistenceManager">
    <constructor-arg>
      <bean class="org.dcache.auth.persistence.AuthRecordPersistenceManager">
        <description>Persistence manager for authentication</description>
        <constructor-arg value="${srm.db.url}"/>
        <constructor-arg value="${srm.db.driver}"/>
        <constructor-arg value="${srm.db.user}"/>
        <constructor-arg value="${srm.db.password}"/>
      </bean>
    </constructor-arg>
  </bean>

  <bean id="login-strategy" class="org.dcache.services.login.CachingLoginStrategy">
    <constructor-arg>
      <bean class="org.dcache.services.login.RemoteLoginStrategy">
        <property name="cellStub" ref="gplazma-stub"/>
      </bean>
    </constructor-arg>
    <constructor-arg value="${srm.service.gplazma.cache.size}"/> <!-- Cache size -->
    <constructor-arg value="${srm.service.gplazma.cache.timeout}"/>
    <constructor-arg value="${srm.service.gplazma.cache.timeout.unit}"/>
  </bean>

  <bean id="authorization" class="diskCacheV111.srm.dcache.DCacheAuthorization">
    <constructor-arg ref="login-strategy"/>
    <constructor-arg ref="auth-persistence-manager"/>
  </bean>

  <bean id="storage" class="diskCacheV111.srm.dcache.Storage"
        init-method="start" destroy-method="stop">
    <description>dCache plugin for SRM</description>
    <property name="directoryListSource" ref="list-handler"/>
    <property name="loginBrokerHandler" ref="lb"/>
    <property name="loginBrokerStub" ref="login-broker-stub"/>
    <property name="pnfsStub" ref="pnfs-stub"/>
    <property name="pnfsHandler" ref="pnfs"/>
    <property name="poolManagerStub" ref="pool-manager-stub"/>
    <property name="spaceManagerStub" ref="space-manager-stub"/>
    <property name="transferManagerStub" ref="transfer-manager-stub"/>
    <property name="copyManagerStub" ref="copy-manager-stub"/>
    <property name="pinManagerStub" ref="pin-manager-stub"/>
    <property name="gplazmaStub" ref="gplazma-stub"/>
    <property name="isSpaceManagerEnabled"
              value="${dcache.enable.space-reservation}"/>
    <property name="loginBrokerUpdatePeriod"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.protocols.loginbroker.period},
                     '${srm.protocols.loginbroker.period.unit}')}" />
    <property name="numberOfDoorsInRandomSelection"
              value="${srm.protocols.population-size}"/>
    <property name="useCustomGetHostByAddress"
              value="${srm.enable.custom-get-host-by-address}"/>
    <property name="httpRootPath" value="${srm.service.webdav.root}"/>
    <property name="xrootdRootPath" value="${srm.service.xrootd.root}"/>
    <property name="configuration" ref="config"/>
    <property name="pinOnlineFiles" value="${srm.enable.pin-online-files}"/>
    <property name="srmPutNotSupportedProtocols" value="${srm.protocols.disallowed.put}"/>
    <property name="srmGetNotSupportedProtocols" value="${srm.protocols.disallowed.get}"/>
    <property name="srmPreferredProtocols" value="${srm.protocols.preferred}"/>
    <property name="srm" ref="srm"/>
  </bean>

  <bean id="config" class="org.dcache.srm.util.Configuration" depends-on="storage">
    <description>SRM configuration</description>
    <property name="port" value="${srm.net.port}"/>
    <property name="timeout"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.external-copy-script.timeout},
                     '${srm.limits.external-copy-script.timeout.unit}')}" />
    <property name="srmHost" value="${srm.net.host}"/>
    <property name="srmHostsAsArray" value="${srm.net.local-hosts}"/>
    <property name="sizeOfSingleRemoveBatch"
              value="${srm.limits.remove-batch-size}"/>
    <property name="maxNumberOfLsEntries"
              value="${srm.limits.request.ls.entries.max}"/>
    <property name="maxNumberOfLsLevels"
              value="${srm.limits.request.ls.levels.max}"/>
    <property name="authzCacheLifetime"
              value="#{T(java.util.concurrent.TimeUnit).
                     SECONDS.convert(
                     ${srm.service.gplazma.cache.timeout},
                     '${srm.service.gplazma.cache.timeout.unit}')}" />
    <property name="srm_root" value="${srm.root}"/>
    <property name="buffer_size" value="${srm.limits.transfer-buffer.size}"/>
    <property name="tcp_buffer_size" value="${srm.limits.transfer-tcp-buffer.size}"/>
    <property name="parallel_streams" value="${srm.limits.parallel-streams}"/>
    <property name="debug" value="${srm.enable.external-copy-script.debug}"/>
    <property name="gsiftpclinet" value="globus-url-copy"/>
    <property name="getLifetime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.get.lifetime},
                     '${srm.limits.request.get.lifetime.unit}')}" />
    <property name="bringOnlineLifetime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.bring-online.lifetime},
                     '${srm.limits.request.bring-online.lifetime.unit}')}" />
    <property name="putLifetime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.put.lifetime},
                     '${srm.limits.request.put.lifetime.unit}')}" />
    <property name="copyLifetime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.copy.lifetime},
                     '${srm.limits.request.copy.lifetime.unit}')}" />
    <property name="recursiveDirectoryCreation"
              value="${srm.enable.recursive-directory-creation}"/>
    <property name="advisoryDelete" value="${srm.enable.advisory-delete}"/>
    <property name="reserve_space_implicitely"
              value="${srm.enable.space-reservation.implicit}"/>
    <property name="space_reservation_strict"
              value="${srm.enable.space-reservation.strict}"/>

    <property name="jdbcUrl" value="${srm.db.url}"/>
    <property name="jdbcClass" value="${srm.db.driver}"/>
    <property name="jdbcUser" value="${srm.db.user}"/>
    <property name="jdbcPass" value="${srm.db.password}"/>
    <property name="jdbcPwdfile" value="${srm.db.password.file}"/>

    <property name="getReqTQueueSize" value="${srm.limits.request.get.scheduler.thread.queue.size}"/>
    <property name="getThreadPoolSize" value="${srm.limits.request.get.scheduler.thread.pool.size}"/>
    <property name="getMaxWaitingRequests" value="${srm.limits.request.get.scheduler.waiting.max}"/>
    <property name="getReadyQueueSize" value="${srm.limits.request.get.scheduler.ready-queue.size}"/>
    <property name="getMaxReadyJobs" value="${srm.limits.request.get.scheduler.ready.max}"/>
    <property name="getMaxNumOfRetries"
              value="${srm.limits.request.get.scheduler.retries.max}"/>
    <property name="getRetryTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.get.scheduler.retry-timeout},
                     '${srm.limits.request.get.scheduler.retry-timeout.unit}')}" />
    <property name="getMaxRunningBySameOwner"
              value="${srm.limits.request.get.scheduler.same-owner-running.max}"/>
    <property name="getSwitchToAsynchronousModeDelay"
              value="#{T(diskCacheV111.srm.dcache.Storage).parseTime(
                     '${srm.limits.request.get.switch-to-async-mode.delay}',
                     '${srm.limits.request.get.switch-to-async-mode.delay.unit}')}"/>
    <property name="bringOnlineReqTQueueSize"
              value="${srm.limits.request.bring-online.scheduler.thread.queue.size}"/>
    <property name="bringOnlineThreadPoolSize"
              value="${srm.limits.request.bring-online.scheduler.thread.pool.size}"/>
    <property name="bringOnlineMaxWaitingRequests"
              value="${srm.limits.request.bring-online.scheduler.waiting.max}"/>
    <property name="bringOnlineReadyQueueSize"
              value="${srm.limits.request.bring-online.scheduler.ready-queue.size}"/>
    <property name="bringOnlineMaxReadyJobs"
              value="${srm.limits.request.bring-online.scheduler.ready.max}"/>
    <property name="bringOnlineMaxNumOfRetries"
              value="${srm.limits.request.bring-online.scheduler.retries.max}"/>
    <property name="bringOnlineRetryTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.bring-online.scheduler.retry-timeout},
                     '${srm.limits.request.bring-online.scheduler.retry-timeout.unit}')}" />
    <property name="bringOnlineMaxRunningBySameOwner"
              value="${srm.limits.request.bring-online.scheduler.same-owner-running.max}"/>
    <property name="bringOnlineSwitchToAsynchronousModeDelay"
              value="#{T(diskCacheV111.srm.dcache.Storage).parseTime(
                     '${srm.limits.request.bring-online.switch-to-async-mode.delay}',
                     '${srm.limits.request.bring-online.switch-to-async-mode.delay.unit}')}"/>
    <property name="lsReqTQueueSize" value="${srm.limits.request.ls.scheduler.thread.queue.size}"/>
    <property name="lsThreadPoolSize" value="${srm.limits.request.ls.scheduler.thread.pool.size}"/>
    <property name="lsMaxWaitingRequests" value="${srm.limits.request.ls.scheduler.waiting.max}"/>
    <property name="lsMaxNumOfRetries"
              value="${srm.limits.request.ls.scheduler.retries.max}"/>
    <property name="lsRetryTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.ls.scheduler.retry-timeout},
                     '${srm.limits.request.ls.scheduler.retry-timeout.unit}')}" />
    <property name="lsMaxRunningBySameOwner"
              value="${srm.limits.request.ls.scheduler.same-owner-running.max}"/>
    <property name="lsSwitchToAsynchronousModeDelay"
              value="#{T(diskCacheV111.srm.dcache.Storage).parseTime(
                     '${srm.limits.request.ls.switch-to-async-mode.delay}',
                     '${srm.limits.request.ls.switch-to-async-mode.delay.unit}')}"/>
    <property name="putReqTQueueSize" value="${srm.limits.request.put.scheduler.thread.queue.size}"/>
    <property name="putThreadPoolSize" value="${srm.limits.request.put.scheduler.thread.pool.size}"/>
    <property name="putMaxWaitingRequests" value="${srm.limits.request.put.scheduler.waiting.max}"/>
    <property name="putReadyQueueSize" value="${srm.limits.request.put.scheduler.ready-queue.size}"/>
    <property name="putMaxReadyJobs" value="${srm.limits.request.put.scheduler.ready.max}"/>
    <property name="putMaxNumOfRetries" value="${srm.limits.request.put.scheduler.retries.max}"/>
    <property name="putRetryTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.put.scheduler.retry-timeout},
                     '${srm.limits.request.put.scheduler.retry-timeout.unit}')}" />
    <property name="putMaxRunningBySameOwner" value="${srm.limits.request.put.scheduler.same-owner-running.max}"/>
    <property name="putSwitchToAsynchronousModeDelay"
              value="#{T(diskCacheV111.srm.dcache.Storage).parseTime(
                     '${srm.limits.request.put.switch-to-async-mode.delay}',
                     '${srm.limits.request.put.switch-to-async-mode.delay.unit}')}"/>
    <property name="copyReqTQueueSize" value="${srm.limits.request.copy.scheduler.thread.queue.size}"/>
    <property name="copyThreadPoolSize" value="${srm.limits.request.copy.scheduler.thread.pool.size}"/>
    <property name="copyMaxWaitingRequests" value="${srm.limits.request.copy.scheduler.waiting.max}"/>
    <property name="copyMaxNumOfRetries" value="${srm.limits.request.copy.scheduler.retries.max}"/>
    <property name="copyRetryTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.request.copy.scheduler.retry-timeout},
                     '${srm.limits.request.copy.scheduler.retry-timeout.unit}')}" />
    <property name="copyMaxRunningBySameOwner"
              value="${srm.limits.request.copy.scheduler.same-owner-running.max}"/>

    <property name="maxQueuedJdbcTasksNum"
              value="${srm.limits.db.queue.size}"/>
    <property name="jdbcExecutionThreadNum"
              value="${srm.limits.db.thread.pool.size}"/>
    <property name="credentialsDirectory"
              value="${srm.user.credentials.directory}"/>
    <property name="overwrite" value="${srm.enable.overwrite}"/>
    <property name="overwrite_by_default" value="${srm.enable.overwrite-by-default}"/>
    <property name="clientDNSLookup" value="${srm.enable.client-dns-lookup}"/>
    <property name="gsissl" value="true"/>
    <property name="clientTransportByName" value="${srm.client-transport}"/>
    <property name="qosPluginClass" value="${srm.plugins.qos.class}"/>
    <property name="qosConfigFile" value="${srm.plugins.qos.config.file}"/>

    <property name="storage" ref="storage"/>
    <property name="srmUserPersistenceManager" ref="auth-persistence-manager"/>
    <property name="authorization" ref="authorization"/>

    <property name="databaseParametersForList.databaseEnabled"
              value="${srm.request.ls.enable.database}"/>
    <property name="databaseParametersForList.expiredRequestRemovalPeriod"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.request.ls.remove-expired-period},
                     '${srm.limits.request.ls.remove-expired-period.unit}')}" />
    <property name="databaseParametersForList.keepRequestHistoryPeriod"
              value="#{T(java.util.concurrent.TimeUnit).DAYS.convert(
                     ${srm.limits.request.ls.keep-history-period},
                     '${srm.limits.request.ls.keep-history-period.unit}')}" />
    <property name="databaseParametersForList.requestHistoryDatabaseEnabled"
              value="${srm.request.ls.enable.history-database}"/>
    <property name="databaseParametersForList.cleanPendingRequestsOnRestart"
              value="${srm.request.ls.enable.clean-pending-on-restart}"/>
    <property name="databaseParametersForList.storeCompletedRequestsOnly"
              value="${srm.request.ls.enable.store-complete-only}"/>

    <property name="databaseParametersForGet.databaseEnabled"
              value="${srm.request.get.enable.database}"/>
    <property name="databaseParametersForGet.expiredRequestRemovalPeriod"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.request.get.remove-expired-period},
                     '${srm.limits.request.get.remove-expired-period.unit}')}" />
    <property name="databaseParametersForGet.keepRequestHistoryPeriod"
              value="#{T(java.util.concurrent.TimeUnit).DAYS.convert(
                     ${srm.limits.request.get.keep-history-period},
                     '${srm.limits.request.get.keep-history-period.unit}')}" />
    <property name="databaseParametersForGet.requestHistoryDatabaseEnabled"
              value="${srm.request.get.enable.history-database}"/>
    <property name="databaseParametersForGet.cleanPendingRequestsOnRestart"
              value="${srm.request.get.enable.clean-pending-on-restart}"/>
    <property name="databaseParametersForGet.storeCompletedRequestsOnly"
              value="${srm.request.get.enable.store-complete-only}"/>

    <property name="databaseParametersForPut.databaseEnabled"
              value="${srm.request.put.enable.database}"/>
    <property name="databaseParametersForPut.expiredRequestRemovalPeriod"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.request.put.remove-expired-period},
                     '${srm.limits.request.put.remove-expired-period.unit}')}" />
    <property name="databaseParametersForPut.keepRequestHistoryPeriod"
              value="#{T(java.util.concurrent.TimeUnit).DAYS.convert(
                     ${srm.limits.request.put.keep-history-period},
                     '${srm.limits.request.put.keep-history-period.unit}')}" />
    <property name="databaseParametersForPut.requestHistoryDatabaseEnabled"
              value="${srm.request.put.enable.history-database}"/>
    <property name="databaseParametersForPut.cleanPendingRequestsOnRestart"
              value="${srm.request.put.enable.clean-pending-on-restart}"/>
    <property name="databaseParametersForPut.storeCompletedRequestsOnly"
              value="${srm.request.put.enable.store-complete-only}"/>

    <property name="databaseParametersForCopy.databaseEnabled"
              value="${srm.request.copy.enable.database}"/>
    <property name="databaseParametersForCopy.expiredRequestRemovalPeriod"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.request.copy.remove-expired-period},
                     '${srm.limits.request.copy.remove-expired-period.unit}')}" />
    <property name="databaseParametersForCopy.keepRequestHistoryPeriod"
              value="#{T(java.util.concurrent.TimeUnit).DAYS.convert(
                     ${srm.limits.request.copy.keep-history-period},
                     '${srm.limits.request.copy.keep-history-period.unit}')}" />
    <property name="databaseParametersForCopy.requestHistoryDatabaseEnabled"
              value="${srm.request.copy.enable.history-database}"/>
    <property name="databaseParametersForCopy.cleanPendingRequestsOnRestart"
              value="${srm.request.copy.enable.clean-pending-on-restart}"/>
    <property name="databaseParametersForCopy.storeCompletedRequestsOnly"
              value="${srm.request.copy.enable.store-complete-only}"/>

    <property name="databaseParametersForBringOnline.databaseEnabled"
              value="${srm.request.bring-online.enable.database}"/>
    <property name="databaseParametersForBringOnline.expiredRequestRemovalPeriod"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.request.bring-online.remove-expired-period},
                     '${srm.limits.request.bring-online.remove-expired-period.unit}')}"/>
    <property name="databaseParametersForBringOnline.keepRequestHistoryPeriod"
              value="#{T(java.util.concurrent.TimeUnit).DAYS.convert(
                     ${srm.limits.request.bring-online.keep-history-period},
                     '${srm.limits.request.bring-online.keep-history-period.unit}')}" />
    <property name="databaseParametersForBringOnline.requestHistoryDatabaseEnabled"
              value="${srm.request.bring-online.enable.history-database}"/>
    <property name="databaseParametersForBringOnline.cleanPendingRequestsOnRestart"
              value="${srm.request.bring-online.enable.clean-pending-on-restart}"/>
    <property name="databaseParametersForBringOnline.storeCompletedRequestsOnly"
              value="${srm.request.bring-online.enable.store-complete-only}"/>

    <property name="databaseParametersForReserve.databaseEnabled"
              value="${srm.request.reserve-space.enable.database}"/>
    <property name="databaseParametersForReserve.expiredRequestRemovalPeriod"
              value="#{T(java.util.concurrent.TimeUnit).SECONDS.convert(
                     ${srm.limits.request.reserve-space.remove-expired-period},
                     '${srm.limits.request.reserve-space.remove-expired-period.unit}')}" />
    <property name="databaseParametersForReserve.keepRequestHistoryPeriod"
              value="#{T(java.util.concurrent.TimeUnit).DAYS.convert(
                     ${srm.limits.request.reserve-space.keep-history-period},
                     '${srm.limits.request.reserve-space.keep-history-period.unit}')}" />
    <property name="databaseParametersForReserve.requestHistoryDatabaseEnabled"
              value="${srm.request.reserve-space.enable.history-database}"/>
    <property name="databaseParametersForReserve.cleanPendingRequestsOnRestart"
              value="${srm.request.reserve-space.enable.clean-pending-on-restart}"/>
    <property name="databaseParametersForReserve.storeCompletedRequestsOnly"
              value="${srm.request.reserve-space.enable.store-complete-only}"/>
  </bean>


  <bean id="srm" class="org.dcache.srm.SRM" factory-method="getSRM"
        destroy-method="stop" depends-on="config">
    <description>SRM engine</description>

    <constructor-arg ref="config"/>
    <constructor-arg value="${srm.cell.name}"/>
  </bean>


  <bean id="thread-pool" class="org.eclipse.jetty.util.thread.QueuedThreadPool"
        init-method="start" destroy-method="stop">
    <description>Thread pool used by Jetty for request processing</description>
    <property name="maxIdleTimeMs"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty.threads.idle-time.max},
                     '${srm.limits.jetty.threads.idle-time.max.unit}')}" />
    <property name="maxThreads" value="${srm.limits.jetty.threads.max}"/>
    <property name="minThreads" value="${srm.limits.jetty.threads.min}"/>
    <property name="name" value="jetty-srm"/>
    <property name="maxQueued" value="${srm.limits.jetty.threads.queued.max}"/>
  </bean>

  <bean id="banned-ciphers" class="org.dcache.util.Crypto"
        factory-method="getBannedCipherSuitesFromConfigurationValue">
    <constructor-arg value="${srm.authn.ciphers}"/>
  </bean>

  <bean id="server" class="org.eclipse.jetty.server.Server"
        init-method="start" destroy-method="stop">
    <description>Jetty server hosting the SRM web application</description>

    <property name="gracefulShutdown" value="${srm.limits.jetty.graceful-shutdown}"/>
    <property name="threadPool" ref="thread-pool"/>

    <property name="connectors">
      <list>
        <ref bean="gsi-connector"/>
        <ref bean="ssl-connector"/>
      </list>
    </property>

    <property name="handler">
      <bean class="org.eclipse.jetty.server.handler.HandlerList">
        <property name="handlers">
          <list>
            <bean class="org.eclipse.jetty.webapp.WebAppContext">
              <property name="contextPath" value="/srm"/>
              <property name="war" value="${dcache.paths.share}/srm-webapp"/>
              <property name="configurationClasses">
                <list>
                  <value>org.eclipse.jetty.webapp.WebInfConfiguration</value>
                  <value>org.eclipse.jetty.plus.webapp.EnvConfiguration</value>
                  <value>org.eclipse.jetty.plus.webapp.PlusConfiguration</value>
                  <value>org.eclipse.jetty.webapp.WebXmlConfiguration</value>
                  <value>org.eclipse.jetty.webapp.TagLibConfiguration</value>
                </list>
              </property>
              <property name="attributes">
                <bean class="org.eclipse.jetty.util.AttributesMap">
                  <constructor-arg>
                    <map>
                      <entry key="#{ T(org.dcache.srm.util.Axis).ATTRIBUTE_NAME_CONFIG }"
                             value-ref="config"/>
                      <entry key="#{ T(org.dcache.srm.util.Axis).ATTRIBUTE_NAME_STORAGE }"
                             value-ref="storage"/>
                      <entry key="#{ T(org.dcache.srm.util.Axis).ATTRIBUTE_NAME_SRM }"
                             value-ref="srm"/>
                    </map>
                  </constructor-arg>
                </bean>
              </property>
            </bean>

            <bean class="org.eclipse.jetty.server.handler.DefaultHandler"/>
          </list>
        </property>
      </bean>
    </property>
  </bean>

  <bean id="gsi-connector"
        class="org.dcache.util.JettyGSIConnector">
    <description>synchronous GSI connector</description>
    <property name="port" value="${srm.net.port}"/>
    <property name="host" value="#{ '${srm.net.listen}'.equals('any') ? null : '${srm.net.listen}' }"/>
    <property name="acceptors" value="${srm.limits.jetty-connector.acceptors}"/>
    <property name="maxIdleTime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty-connector.idle-time.max},
                     '${srm.limits.jetty-connector.idle-time.max.unit}')}" />
    <property name="lowResourceMaxIdleTime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty-connector.low-resource.max.idle-time},
                     '${srm.limits.jetty-connector.low-resource.max.idle-time.unit}')}" />
    <property name="acceptQueueSize" value="${srm.limits.jetty-connector.backlog}"/>
    <property name="hostCertificatePath" value="${srm.authn.hostcert.cert}"/>
    <property name="hostKeyPath" value="${srm.authn.hostcert.key}"/>
    <property name="caCertificatePath" value="${srm.authn.capath}"/>
    <property name="autoFlush" value="true"/>
    <property name="encrypt" value="true"/>
    <property name="requireClientAuth" value="true"/>
    <property name="acceptNoClientCerts" value="false"/>
    <property name="gssMode" value="gsi"/>
    <property name="handshakeTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty-connector.handshake.timeout},
                     '${srm.limits.jetty-connector.handshake.timeout.unit}')}" />
    <property name="hostCertRefreshInterval" value="${srm.authn.hostcert.refresh}" />
    <property name="hostCertRefreshIntervalUnit" value="${srm.authn.hostcert.refresh.unit}" />
    <property name="trustAnchorRefreshInterval" value="${srm.authn.capath.refresh}" />
    <property name="trustAnchorRefreshIntervalUnit" value="${srm.authn.capath.refresh.unit}" />
    <property name="excludeCipherSuites" ref="banned-ciphers"/>
  </bean>

  <bean id="ssl-connector"
        class="org.dcache.util.JettyGSIConnector">
    <description>synchronous SSL connector</description>
    <property name="port" value="${srm.net.ssl-port}"/>
    <property name="host" value="#{ '${srm.net.listen}'.equals('any') ? null : '${srm.net.listen}' }"/>
    <property name="acceptors" value="${srm.limits.jetty-connector.acceptors}"/>
    <property name="maxIdleTime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty-connector.idle-time.max},
                     '${srm.limits.jetty-connector.idle-time.max.unit}')}" />
    <property name="lowResourceMaxIdleTime"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty-connector.low-resource.max.idle-time},
                     '${srm.limits.jetty-connector.low-resource.max.idle-time.unit}')}" />
    <property name="acceptQueueSize" value="${srm.limits.jetty-connector.backlog}"/>
    <property name="hostCertificatePath" value="${srm.authn.hostcert.cert}"/>
    <property name="hostKeyPath" value="${srm.authn.hostcert.key}"/>
    <property name="caCertificatePath" value="${srm.authn.capath}"/>
    <property name="autoFlush" value="true"/>
    <property name="encrypt" value="true"/>
    <property name="requireClientAuth" value="true"/>
    <property name="acceptNoClientCerts" value="false"/>
    <property name="gssMode" value="ssl"/>
    <property name="handshakeTimeout"
              value="#{T(java.util.concurrent.TimeUnit).MILLISECONDS.convert(
                     ${srm.limits.jetty-connector.handshake.timeout},
                     '${srm.limits.jetty-connector.handshake.timeout.unit}')}" />
    <property name="hostCertRefreshInterval" value="${srm.authn.hostcert.refresh}" />
    <property name="hostCertRefreshIntervalUnit" value="${srm.authn.hostcert.refresh.unit}" />
    <property name="trustAnchorRefreshInterval" value="${srm.authn.capath.refresh}" />
    <property name="trustAnchorRefreshIntervalUnit" value="${srm.authn.capath.refresh.unit}" />
    <property name="excludeCipherSuites" ref="banned-ciphers"/>
  </bean>
</beans>
