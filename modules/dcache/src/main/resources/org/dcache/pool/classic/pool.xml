<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:task="http://www.springframework.org/schema/task"

       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/task
           http://www.springframework.org/schema/task/spring-task.xsd">


    <context:property-placeholder/>
  <context:annotation-config/>

    <!--
        Convert protperies with multiple values separated by comma into an array of strings:
        key=value1,value2,value3 : String[] {value1, value2, value3}
    -->
    <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
        <property name="customEditors">
            <map>
                <entry key="java.lang.String[]"
                    value="org.springframework.beans.propertyeditors.StringArrayPropertyEditor" />
            </map>
        </property>
    </bean>

  <bean id="noroutetocell" class="org.dcache.cells.LogNoRouteToCellExceptionReceiver">
      <description>Undeliverable message logger</description>
      <property name="excludedDestinations" value="${pool.destination.heartbeat},${pool.destination.corrupt-file}"/>
      <property name="excludedMessages" value="diskCacheV111.vehicles.DoorTransferFinishedMessage"/>
  </bean>

  <!-- The lock protects the pool from being accessed by multiple
       instances. If the lock cannot be acquired, pool creation will
       fail with an exception. Although the wrapper script will
       immediately restart the pool, the pool is protected from
       corruption.
  -->
  <bean id="lock" class="org.dcache.util.LockFile"
        init-method="acquire" destroy-method="release">
    <description>Pool lock</description>
    <constructor-arg value="${pool.path}/lock"/>
  </bean>

  <bean id="replica-state-policy"
        class="org.dcache.pool.classic.LFSReplicaStatePolicyFactory"
        factory-method="createInstance">
    <description>Defines the state of new replicas</description>
    <constructor-arg value="${pool.lfs}"/>
  </bean>

  <bean id="pool-mode" class="diskCacheV111.pools.PoolV2Mode">
      <description>Pool mode</description>
  </bean>

  <bean id="pool" class="org.dcache.pool.classic.PoolV4"
        init-method="init">
    <description>Main pool component</description>
    <property name="poolName" value="${pool.name}"/>

    <property name="baseDir"
              value="${pool.path}"/>
    <property name="version"
              value="4"/>
    <property name="poolUpDestination"
              value="${pool.destination.heartbeat}"/>
    <property name="replicationNotificationDestination"
              value="${pool.destination.replicate}"/>
    <property name="replicationIp"
              value="${pool.destination.replicate.ip}"/>
    <property name="tags"
              value="${pool.tags}"/>
    <property name="pnfsHandler" ref="pnfs"/>
    <property name="repository" ref="rep"/>
    <property name="storageQueue" ref="queue"/>
    <property name="storageHandler" ref="storagehandler"/>
    <property name="HSMSet" ref="hsmset"/>
    <property name="flushController" ref="flush"/>
    <property name="PPClient" ref="p2p"/>
    <property name="account" ref="account"/>
    <property name="replicaStatePolicy" ref="replica-state-policy"/>
    <property name="volatile"
              value="#{ '${pool.lfs}' == 'volatile' or '${pool.lfs}' == 'transient' }"/>
    <property name="hasTapeBackend"
              value="#{ '${pool.lfs}' == 'none' }"/>
    <property name="transferServices" ref="transfer-services" />
    <property name="ioQueueManager" ref="io-queue-manager" />
    <property name="poolMode" ref="pool-mode"/>
    <property name="billingStub" ref="billing-stub"/>
    <property name="executor" ref="workerThreadPool"/>
    <property name="enableHsmFlag" value="${pool.enable.hsm-flag}"/>
  </bean>

  <bean id="pnfs" class="diskCacheV111.util.PnfsHandler">
    <description>PNFS manager client module</description>
    <constructor-arg ref="pnfsStub"/>
    <constructor-arg value="${pool.name}"/>
  </bean>

  <bean id="checksum-replica-store"
        class="org.dcache.pool.repository.checksums.ChecksumReplicaStore">
      <constructor-arg>
          <bean class="org.dcache.pool.statistics.IoStatisticsReplicaStore">
              <constructor-arg>
                  <bean class="org.dcache.pool.repository.ConsistentReplicaStore" init-method="init">
                      <constructor-arg ref="csm"/>
                      <constructor-arg ref="pnfs"/>
                      <constructor-arg>
                          <bean class="${pool.plugins.meta}" init-method="init">
                              <description>Store for pool meta data</description>
                              <constructor-arg ref="file-store"/>
                              <constructor-arg value="#{ T(java.nio.file.FileSystems).getDefault().getPath('${pool.path.meta}') }"/>
                              <constructor-arg value="${pool.name}"/>
                          </bean>
                      </constructor-arg>

                      <constructor-arg ref="replica-state-policy"/>
                      <property name="poolName" value="${pool.name}"/>
                  </bean>
              </constructor-arg>
          </bean>
      </constructor-arg>
      <constructor-arg ref="csm"/>
  </bean>

  <bean id="sweeper" class="${pool.plugins.sweeper}"
          init-method="start" destroy-method="stop">
    <description>Pool garbage collector</description>
    <property name="repository" ref="rep"/>
    <property name="account" ref="account"/>
    <property name="margin" value="${pool.limits.sweeper-margin}"/>
  </bean>

  <bean id="rep"
        class="org.dcache.pool.repository.v5.ReplicaRepository"
        destroy-method="shutdown">
    <description>Repository manager</description>
    <property name="executor" ref="workerThreadPool"/>
    <property name="pnfsHandler" ref="pnfs"/>
    <property name="account" ref="account"/>
    <property name="spaceSweeperPolicy" ref="sweeper"/>
    <property name="volatile"
              value="#{ '${pool.lfs}' == 'volatile' or '${pool.lfs}' == 'transient' }"/>
    <property name="maxDiskSpaceString" value="${pool.size}"/>
    <property name="replicaStore" ref="replica-store"/>
    <property name="scanThreads" value="${pool.limits.scan-threads}"/>
  </bean>

  <bean id="repository-interpreter" class="org.dcache.pool.repository.RepositoryInterpreter">
    <description>Repository user interface</description>
    <property name="repository" ref="rep"/>
    <property name="statisticsListener" ref="pool-info-statistics-listener"/>
  </bean>

  <bean id="scanner" class="org.dcache.pool.classic.ChecksumScanner">
    <description>Implements background checksum verification</description>
    <property name="poolName" value="${pool.name}"/>
    <property name="repository" ref="rep"/>
    <property name="checksumModule" ref="csm"/>
    <property name="scrubberStateFile" value="${pool.path}/scrubber.state"/>
  </bean>

  <bean id="csm" class="org.dcache.pool.classic.ChecksumModuleV1">
    <description>Checksum module</description>
  </bean>

  <bean id="queue" class="org.dcache.pool.classic.StorageClassContainer">
      <description>HSM flush queue manager</description>
      <property name="repository" ref="rep"/>
      <property name="nearlineStorageHandler" ref="storagehandler"/>
  </bean>

  <bean id="storagehandler" class="org.dcache.pool.nearline.NearlineStorageHandler">
      <description>Nearline storage manager</description>
      <property name="scheduledExecutor" ref="workerThreadPool"/>
      <property name="executor">
          <bean class="org.dcache.util.CDCListeningExecutorServiceDecorator"
                destroy-method="shutdown">
              <constructor-arg>
                  <bean class="org.dcache.util.BoundedCachedExecutor">
                      <constructor-arg value="${pool.limits.nearline-threads}"/>
                  </bean>
              </constructor-arg>
          </bean>
      </property>
      <property name="repository" ref="rep"/>
      <property name="checksumModule" ref="csm"/>
      <property name="pnfsHandler" ref="pnfs"/>
      <property name="billingStub" ref="billing-stub"/>
      <property name="hsmSet" ref="hsmset"/>
      <property name="allocator" ref="allocator" />
      <property name="fileStore" ref="file-store" />
      <property name="stickyOnStageDuration" value="${pool.sticky-on-stage-duration}" />
      <property name="stickyOnStageDurationUnit" value="${pool.sticky-on-stage-duration.unit}" />
  </bean>

  <bean id="hsmset" class="org.dcache.pool.nearline.HsmSet">
    <description>HSM backend manager</description>
  </bean>

  <bean id="jtm" class="org.dcache.pool.classic.JobTimeoutManager"
          init-method="start" destroy-method="stop">
      <description>Job timeout manager</description>
      <property name="ioQueueManager" ref="io-queue-manager"/>
  </bean>

  <bean id="flush" class="org.dcache.pool.classic.HsmFlushController">
      <description>Controller for centralising flushing</description>
      <property name="storageClassContainer" ref="queue"/>
      <property name="poolMode" ref="pool-mode"/>
    <property name="queueOrder" value="${pool.flush-controller.queue-order}"/>
  </bean>

  <bean id="billing-stub" class="org.dcache.cells.CellStub">
      <description>Billing communication stub</description>
      <property name="destination" value="${pool.service.billing}"/>
  </bean>

  <bean id="corrupt-file-topic" class="org.dcache.cells.CellStub">
        <description>Topic communication stub</description>
        <property name="destination" value="${pool.destination.corrupt-file}"/>
  </bean>

  <bean id="pnfsStub" class="org.dcache.cells.CellStub">
    <description>PNFS manager cell stub</description>
      <property name="destination" value="${pool.service.pnfsmanager}"/>
      <property name="timeout" value="${pool.service.pnfsmanager.timeout}"/>
      <property name="timeoutUnit" value="${pool.service.pnfsmanager.timeout.unit}"/>
      <property name="rate" value="${pool.service.pnfsmanager.rate}"/>
  </bean>

  <bean id="poolStub" class="org.dcache.cells.CellStub">
    <description>Pool cell stub</description>
    <property name="timeout" value="${pool.service.pool.timeout}"/>
    <property name="timeoutUnit" value="${pool.service.pool.timeout.unit}"/>
  </bean>

  <bean id="poolManagerStub" class="org.dcache.cells.CellStub">
    <description>Pool manager cell stub</description>
      <property name="destination" value="${pool.service.poolmanager}"/>
      <property name="timeout" value="${pool.service.poolmanager.timeout}"/>
      <property name="timeoutUnit" value="${pool.service.poolmanager.timeout.unit}"/>
  </bean>

  <bean id="doorStub" class="org.dcache.cells.CellStub">
      <description>Door cell stub</description>
      <property name="timeout" value="${pool.service.door.timeout}"/>
      <property name="timeoutUnit" value="${pool.service.door.timeout.unit}"/>
  </bean>

  <bean id="workerThreadPool"
        class="org.dcache.util.CDCScheduledExecutorServiceDecorator">
      <description>Thread pool for background tasks</description>
      <constructor-arg>
          <bean class="java.util.concurrent.Executors"
                factory-method="newScheduledThreadPool"
                 destroy-method="shutdown">
              <constructor-arg value="${pool.limits.worker-threads}"/>
              <property name="executeExistingDelayedTasksAfterShutdownPolicy"
                        value="false"/>
              <property name="continueExistingPeriodicTasksAfterShutdownPolicy"
                        value="false"/>
          </bean>
      </constructor-arg>
  </bean>

  <bean id="pinManagerStub" class="org.dcache.cells.CellStub">
    <description>Pin manager cell stub</description>
      <property name="destination" value="${pool.service.pinmanager}"/>
      <property name="timeout" value="${pool.service.pinmanager.timeout}"/>
      <property name="timeoutUnit" value="${pool.service.pinmanager.timeout.unit}"/>
  </bean>


  <bean id="p2p-parent" abstract="true" class="org.dcache.pool.p2p.P2PClient"
        destroy-method="shutdown">
    <description>Pool to pool transfer manager</description>
    <property name="repository" ref="rep"/>
    <property name="checksumModule" ref="csm"/>
    <property name="pnfs" ref="pnfsStub"/>
    <property name="pool" ref="poolStub"/>
    <property name="executor" ref="workerThreadPool"/>
  </bean>


    <bean id="ssl-context-builder-parent" abstract="true" class="org.dcache.http.AbstractSslContextSupplier">
        <description>Abstract SSL Context factory</description>
        <property name="serverCertificatePath" value="${pool.mover.https.hostcert.cert}"/>
        <property name="serverKeyPath" value="${pool.mover.https.hostcert.key}"/>
        <property name="serverCaPath" value="${pool.mover.https.capath}"/>
        <property name="crlCheckingMode" value="${pool.authn.crl-mode}"/>
        <property name="ocspCheckingMode" value="${pool.authn.ocsp-mode}"/>
    </bean>

  <bean id="netty-ssl-context-builder" class="org.dcache.http.NettySslContextFactory" parent="ssl-context-builder-parent">
    <description>SSL Context factory for Netty</description>
  </bean>

  <bean id="jdk-ssl-context-builder" class="org.dcache.http.JdkSslContextFactory" parent="ssl-context-builder-parent">
    <description>SSL Context factory for JDK</description>
  </bean>

  <bean id="migration" class="org.dcache.pool.migration.MigrationModule"
        destroy-method="cancelAll">
    <description>Replica migration module client</description>
    <constructor-arg>
        <bean class="org.dcache.pool.migration.MigrationContextImpl">
            <property name="repository" ref="rep"/>
            <property name="executor" ref="workerThreadPool"/>
            <property name="pnfsStub" ref="pnfsStub"/>
            <property name="poolStub" ref="poolStub"/>
            <property name="poolManagerStub" ref="poolManagerStub"/>
            <property name="pinManagerStub" ref="pinManagerStub"/>
        </bean>
    </constructor-arg>
  </bean>

  <bean id="migration-server"
        class="org.dcache.pool.migration.MigrationModuleServer">
    <description>Replica migration module backend</description>
    <property name="repository" ref="rep"/>
    <property name="migrationModule" ref="migration"/>
    <property name="PPClient" ref="p2p"/>
    <property name="executor" ref="workerThreadPool"/>
    <property name="checksumModule" ref="csm"/>
    <property name="poolMode" ref="pool-mode"/>
  </bean>

  <bean id="allocator" class="org.dcache.pool.classic.FairQueueAllocator">
    <description>Space allocation policy for nearline storage</description>
    <constructor-arg>
      <bean class="org.dcache.pool.classic.BlockingAllocator">
	<constructor-arg ref="account"/>
      </bean>
    </constructor-arg>
  </bean>

  <bean id="io-queue-manager" class="org.dcache.pool.classic.IoQueueManager"
          destroy-method="shutdown" depends-on="transfer-services">
    <description>Requests IO manager</description>
    <property name="queues" value="${pool.queues}"/>
  </bean>

  <bean id="default-transfer-service" class="org.dcache.pool.classic.MoverMapTransferService"
          destroy-method="shutdown" depends-on="rep">
      <description>Generic transfer service</description>
      <property name="postTransferService" ref="post-transfer-service"/>
  </bean>

  <bean id="nfs-transfer-service" class="org.dcache.chimera.nfsv41.mover.NfsTransferService"
        init-method="init" destroy-method="shutdown" depends-on="rep">
      <description>NFSv4.1 transfer service</description>
      <property name="enableGss" value="${pool.mover.nfs.rpcsec_gss}" />
      <property name="postTransferService" ref="post-transfer-service"/>
      <property name="pnfsHandler" ref="pnfs"/>
      <property name="doorStub" ref="doorStub"/>
      <property name="minTcpPort" value="${pool.mover.nfs.port.min}"/>
      <property name="maxTcpPort" value="${pool.mover.nfs.port.max}"/>
      <property name="tcpPortFile" value="${pool.path}/mover-tcp-port.nfs"/>
      <property name="ioStrategy" value="${pool.mover.nfs.thread-policy}" />

  </bean>

  <bean id="signing-policy"
        class="org.dcache.xrootd.security.SigningPolicy">
    <constructor-arg name="secLvl" value="${pool.mover.xrootd.security.level}"/>
    <constructor-arg name="force" value="${pool.mover.xrootd.security.force-signing}"/>
  </bean>

  <!-- Build the parser for processing text like "8 MiB" -->
  <bean id="byte-size-parser-builder" class="org.dcache.util.ByteSizeParser" factory-method="using">
    <constructor-arg value="#{ T(org.dcache.util.ByteUnits).isoSymbol() }"/>
  </bean>
  <bean id="byteSizeParser" factory-bean="byte-size-parser-builder" factory-method="build"/>

  <bean id="xrootd-transfer-service" class="org.dcache.xrootd.pool.XrootdTransferService"
          depends-on="rep">
      <description>Xrootd transfer service</description>
      <property name="postTransferService" ref="post-transfer-service"/>
      <property name="pnfsStub" ref="pnfsStub"/>
      <property name="threads" value="${pool.mover.xrootd.threads}"/>
      <property name="connectTimeout" value="${pool.mover.xrootd.timeout.connect}"/>
      <property name="connectTimeoutUnit" value="${pool.mover.xrootd.timeout.connect.unit}"/>
      <property name="tpcClientChunkSize" value="#{ byteSizeParser.parse('${pool.mover.xrootd.tpc-client-chunk-size}') }"/>
      <property name="maxFrameSize" value="#{ byteSizeParser.parse('${pool.mover.xrootd.frame-size}') }"/>
      <property name="maxWriteBufferSize" value="#{ byteSizeParser.parse('${pool.mover.xrootd.write-buffer-size}') }"/>
      <property name="readReconnectTimeout" value="${pool.mover.xrootd.read-reconnect-timeout}"/>
      <property name="readReconnectTimeoutUnit" value="${pool.mover.xrootd.read-reconnect-timeout.unit}"/>
      <property name="accessLogPlugins">
        <bean class="org.dcache.xrootd.spring.ChannelHandlerFactoryFactoryBean">
          <property name="plugins" value="access-log"/>
        </bean>
      </property>
      <property name="plugins">
          <bean class="org.dcache.xrootd.spring.ChannelHandlerFactoryFactoryBean">
              <property name="plugins" value="${pool.mover.xrootd.plugins}"/>
          </bean>
      </property>
      <property name="sslHandlerFactories">
        <bean class="org.dcache.xrootd.spring.ChannelHandlerFactoryFactoryBean">
          <description>Factory for ssl handler</description>
          <property name="plugins" value="${pool.mover.xrootd.security.ssl-plugins}"/>
        </bean>
      </property>
      <property name="doorStub" ref="doorStub"/>
      <property name="portRange">
          <bean class="org.dcache.util.NettyPortRange">
              <constructor-arg value="${pool.mover.xrootd.port.min}"/>
              <constructor-arg value="${pool.mover.xrootd.port.max}"/>
          </bean>
      </property>
      <property name="queryConfig">
          <bean class="org.dcache.util.configuration.ConfigurationMapFactoryBean">
              <property name="prefix" value="pool.mover.xrootd.query-config"/>
          </bean>
      </property>
      <property name="tpcClientPlugins">
          <bean class="org.dcache.xrootd.spring.ChannelHandlerFactoryFactoryBean">
            <property name="plugins" value="${pool.mover.xrootd.tpc-authn-plugins}"/>
          </bean>
      </property>
      <property name="thirdPartyShutdownExecutor" ref="workerThreadPool"/>
      <property name="signingPolicy" ref="signing-policy"/>
      <property name="tpcServerResponseTimeout" value="${pool.mover.xrootd.tpc-server-response-timeout}"/>
      <property name="tpcServerResponseTimeoutUnit" value="${pool.mover.xrootd.tpc-server-response-timeout.unit}"/>
    <property name="serverProtocolFlags">
      <bean class="org.dcache.xrootd.util.ServerProtocolFlags">
        <property name="allowsAnonymousGPFile" value="false"/>
        <property name="dataServer" value="false"/>
        <property name="loadBalancingServer" value="false"/>
        <property name="managerRole" value="false"/>
        <property name="metaServerRole" value="false"/>
        <property name="proxyServerRole" value="false"/>
        <property name="mode" value="${pool.mover.xrootd.security.tls.mode}"/>
        <property name="requiresTLSForData" value="${pool.mover.xrootd.security.tls.require-data}"/>
        <property name="requiresTLSForGPF" value="${pool.mover.xrootd.security.tls.require-gpf}"/>
        <property name="requiresTLSForLogin" value="${pool.mover.xrootd.security.tls.require-login}"/>
        <property name="requiresTLSForSession" value="${pool.mover.xrootd.security.tls.require-session}"/>
        <property name="requiresTLSForTPC" value="${pool.mover.xrootd.security.tls.require-tpc}"/>
        <property name="serverRole" value="true"/>
        <property name="supervisorRole" value="false"/>
        <property name="supportsGPFile" value="false"/>
        <property name="supportsPersistOnClose" value="false"/>
        <property name="supportsPGReadWrite" value="false"/>
        <property name="supportsTLS" value="true"/>
      </bean>
    </property>
  </bean>

  <bean id="http-transfer-service-parent" abstract="true"
            class="org.dcache.http.HttpTransferService" depends-on="rep">
        <description>Abstract HTTP transfer service</description>
        <property name="postTransferService" ref="post-transfer-service"/>
        <property name="threads" value="${pool.mover.http.threads}"/>
        <property name="chunkSize" value="${pool.mover.http.chunk-size}"/>
        <property name="connectTimeout" value="${pool.mover.http.timeout.connect}"/>
        <property name="connectTimeoutUnit" value="${pool.mover.http.timeout.connect.unit}"/>
        <property name="doorStub" ref="doorStub"/>
        <property name="portRange">
            <bean class="org.dcache.util.NettyPortRange">
                <constructor-arg value="${pool.mover.http.port.min}"/>
                <constructor-arg value="${pool.mover.http.port.max}"/>
            </bean>
        </property>
        <property name="customHeaders" ref="custom-headers"/>
    </bean>

    <bean id="http-transfer-service"  parent="http-transfer-service-parent">
        <description>HTTP transfer service</description>
    </bean>

  <bean id="remote-http-transfer-service" class="org.dcache.pool.classic.RemoteHttpTransferService"
          depends-on="rep" destroy-method="shutdown">
      <property name="postTransferService" ref="post-transfer-service"/>
      <property name="certificateAuthorityPath" value="${pool.mover.http-tpc.authn.capath}"/>
      <property name="certificateAuthorityUpdateInterval" value="${pool.mover.http-tpc.authn.capath.refresh}"/>
      <property name="certificateAuthorityUpdateIntervalUnit" value="${pool.mover.http-tpc.authn.capath.refresh.unit}"/>
      <property name="namespaceMode" value="${pool.mover.http-tpc.authn.namespace-mode}"/>
      <property name="crlCheckingMode" value="${pool.mover.http-tpc.authn.crl-mode}"/>
      <property name="ocspCheckingMode" value="${pool.mover.http-tpc.authn.ocsp-mode}"/>
  </bean>

  <bean id="banned-ciphers" class="org.dcache.util.Crypto"
        factory-method="getBannedCipherSuitesFromConfigurationValue">
      <constructor-arg value="${pool.authn.ciphers}"/>
  </bean>

  <bean id="remote-gsiftp-transfer-service" class="org.dcache.pool.classic.RemoteGsiftpTransferService"
          depends-on="rep" destroy-method="shutdown">
      <property name="postTransferService" ref="post-transfer-service"/>
      <property name="certificateAuthorityPath" value="${pool.mover.remote-gsiftp.authn.capath}"/>
      <property name="certificateAuthorityUpdateInterval" value="${pool.mover.remote-gsiftp.authn.capath.refresh}"/>
      <property name="certificateAuthorityUpdateIntervalUnit" value="${pool.mover.remote-gsiftp.authn.capath.refresh.unit}"/>
      <property name="namespaceMode" value="${pool.mover.remote-gsiftp.authn.namespace-mode}"/>
      <property name="crlCheckingMode" value="${pool.mover.remote-gsiftp.authn.crl-mode}"/>
      <property name="ocspCheckingMode" value="${pool.mover.remote-gsiftp.authn.ocsp-mode}"/>
      <property name="bannedCiphers" ref="banned-ciphers"/>
      <property name="portRange">
          <bean class="org.dcache.util.PortRange">
              <constructor-arg value="${pool.mover.ftp.port.min}"/>
              <constructor-arg value="${pool.mover.ftp.port.max}"/>
          </bean>
      </property>
  </bean>

  <bean id="post-transfer-service"  class="org.dcache.pool.classic.DefaultPostTransferService"
          init-method="init" destroy-method="shutdown" depends-on="rep">
       <description>Post processing execution service</description>
       <property name="billingStub" ref="billing-stub"/>
       <property name="poolName" value="${pool.name}"/>
       <property name="checksumModule" ref="csm"/>
  </bean>


  <bean id="abstract-transfer-service" abstract="true" class="org.dcache.pool.classic.TransferServices">
      <description>Collection of transfer services</description>
      <property name="defaultFactory" ref="default-transfer-service"/>
      <property name="factories">
        <map>
            <entry key="NFS4-4" value-ref="nfs-transfer-service" />
            <!-- Xrootd-2 is here for backward compatibility with doors
                 that have not been updated to the new version and should
                 be removed in the future. -->
            <entry key="Xrootd-2" value-ref="xrootd-transfer-service"/>
            <entry key="Xrootd-4" value-ref="xrootd-transfer-service"/>
            <entry key="Xrootd-5" value-ref="xrootd-transfer-service"/>
            <!-- Support new "xroot" protocol name -->
            <entry key="xroot-2" value-ref="xrootd-transfer-service"/>
            <entry key="xroot-4" value-ref="xrootd-transfer-service"/>
            <entry key="xroot-5" value-ref="xrootd-transfer-service"/>
            <entry key="Http-1" value-ref="http-transfer-service"/>
            <entry key="RemoteHttpDataTransfer-1" value-ref="remote-http-transfer-service"/>
            <entry key="RemoteHttpsDataTransfer-1" value-ref="remote-http-transfer-service"/>
            <entry key="RemoteGsiftpTransfer-1" value-ref="remote-gsiftp-transfer-service"/>
        </map>
      </property>
  </bean>

  <bean id="custom-headers"
	class="org.dcache.util.configuration.ConfigurationMapFactoryBean">
      <property name="prefix" value="pool.mover.http.custom-response-header"/>
  </bean>

  <bean id="resilience-message-handler" class="org.dcache.pool.resilience.ResilienceMessageHandler"
    init-method="initialize">
    <description>For communication with the replica manager</description>
    <property name="executionService">
      <bean class="org.dcache.util.CDCExecutorServiceDecorator">
        <constructor-arg>
          <bean class="java.util.concurrent.Executors" factory-method="newFixedThreadPool"
                destroy-method="shutdownNow">
            <constructor-arg value="${pool.resilience.request-threads}"/>
          </bean>
        </constructor-arg>
      </bean>
    </property>
    <property name="repository" ref="rep"/>
    <property name="poolName" value="${pool.name}"/>
    <property name="listener">
      <bean class="org.dcache.pool.resilience.BrokenFileListener">
        <constructor-arg ref="corrupt-file-topic"/>
        <constructor-arg value="${pool.name}"/>
      </bean>
    </property>
  </bean>

  <!-- this will eventually deprecate the preceding listener -->
  <bean id="qos-message-handler" class="org.dcache.pool.qos.QoSMessageHandler"
    init-method="initialize">
    <description>For communication with the qos components</description>
    <property name="executionService">
      <bean class="org.dcache.util.CDCExecutorServiceDecorator">
        <constructor-arg>
          <bean class="java.util.concurrent.Executors" factory-method="newFixedThreadPool"
            destroy-method="shutdownNow">
            <constructor-arg value="${pool.qos.request-threads}"/>
          </bean>
        </constructor-arg>
      </bean>
    </property>
    <property name="repository" ref="rep"/>
    <property name="listener">
      <bean class="org.dcache.pool.qos.BrokenFileNotifier">
        <constructor-arg ref="corrupt-file-topic"/>
        <constructor-arg value="${pool.name}"/>
      </bean>
    </property>
  </bean>

  <bean id="pool-info-statistics-listener" class="org.dcache.pool.statistics.StatisticsListener"
        init-method="initialize">
    <property name="repository" ref="rep"/>
  </bean>

  <bean id="pool-info-request-handler" class="org.dcache.pool.PoolInfoRequestHandler">
    <description>Handles requests from frontend services for pool data.</description>
    <property name="executor">
      <bean class="java.util.concurrent.Executors" factory-method="newFixedThreadPool"
            destroy-method="shutdownNow">
        <constructor-arg value="${pool.info-request-handler.threads}"/>
      </bean>
    </property>
    <property name="pool" ref="pool"/>
    <property name="checksumModule" ref="csm"/>
    <property name="flushController" ref="flush"/>
    <property name="hsmFlushQueueManager" ref="queue"/>
    <property name="jobTimeoutManager" ref="jtm"/>
    <property name="migrationClient" ref="migration"/>
    <property name="migrationServer" ref="migration-server"/>
    <property name="p2pClient" ref="p2p"/>
    <property name="queueManager" ref="io-queue-manager"/>
    <property name="repositoryDataProvider" ref="rep"/>
    <property name="repository" ref="rep"/>
    <property name="storageHandler" ref="storagehandler"/>
    <property name="sweeper" ref="sweeper"/>
    <property name="transferServices" ref="transfer-services"/>
    <property name="statisticsListener" ref="pool-info-statistics-listener"/>
  </bean>

  <beans profile="healthcheck-true">
    <bean id="healthcheck" class="org.dcache.pool.repository.v5.CheckHealthTask">
      <description>Periodic task for checking pool health</description>
      <property name="repository" ref="rep"/>
      <property name="account" ref="account"/>
      <property name="replicaStore" ref="replica-store"/>
      <property name="command" value="${pool.check-health-command}"/>
    </bean>

    <task:scheduled-tasks scheduler="healthcheck-scheduler">
      <task:scheduled ref="healthcheck" method="run" fixed-delay="60000"/>
    </task:scheduled-tasks>

    <!-- Instead of <task:scheduler id="healthcheck-scheduler"/> -->
    <bean id="healthcheck-scheduler" class="org.dcache.util.CDCThreadPoolTaskScheduler"/>
  </beans>

  <beans profile="backend-posix">
      <bean id="file-store" class="org.dcache.pool.repository.FlatFileStore">
          <description>Store for pool files</description>
          <constructor-arg value="#{ T(java.nio.file.FileSystems).getDefault().getPath('${pool.path}') }"/>
      </bean>
  </beans>

    <beans profile="kafka-true">

       <bean id="listener" class="org.dcache.kafka.LoggingProducerListener"/>


        <bean id="kafka-configs-remove" class="org.dcache.util.configuration.ConfigurationMapFactoryBean">
            <property name="prefix" value="pool.kafka.producer.configs"/>
            <property name="staticEnvironment">
                <map>
                    <entry key="bootstrap.servers" value="${pool.kafka.producer.bootstrap.servers}"/>
                    <entry key="key.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>
                    <entry key="value.serializer" value="org.dcache.notification.RemoveFileInfoMessageSerializer"/>
                    <entry key="client.id" value="${pool.cell.name}@${dcache.domain.name}-remove"/>
                </map>
            </property>
        </bean>



        <bean id="billing-template-remove"  class="org.springframework.kafka.core.KafkaTemplate">
            <qualifier value="remove"/>
            <constructor-arg>
                <bean class="org.springframework.kafka.core.DefaultKafkaProducerFactory">
                    <constructor-arg name="configs" ref ="kafka-configs-remove"/>
                </bean>
            </constructor-arg>
            <property name="defaultTopic" value="${pool.kafka.topic}"/>
            <property name="producerListener" ref="listener"/>
        </bean>


        <bean id="kafka-configs-hsm" class="org.dcache.util.configuration.ConfigurationMapFactoryBean">
            <property name="prefix" value="pool.kafka.producer.configs"/>
            <property name="staticEnvironment">
                <map>
                    <entry key="bootstrap.servers" value="${pool.kafka.producer.bootstrap.servers}"/>
                    <entry key="key.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>
                    <entry key="value.serializer" value="org.dcache.notification.StorageInfoMessageSerializer"/>
                    <entry key="client.id" value="${pool.cell.name}@${dcache.domain.name}-hsm"/>
                </map>
            </property>
        </bean>



        <bean id="billing-template-hsm"  class="org.springframework.kafka.core.KafkaTemplate">
            <qualifier value="hsm"/>
            <constructor-arg>
                <bean class="org.springframework.kafka.core.DefaultKafkaProducerFactory">
                    <constructor-arg name="configs" ref ="kafka-configs-hsm"/>
                </bean>
            </constructor-arg>
            <property name="defaultTopic" value="${pool.kafka.topic}"/>
            <property name="producerListener" ref="listener"/>
        </bean>


        <bean id="kafka-configs-transfer" class="org.dcache.util.configuration.ConfigurationMapFactoryBean">
            <property name="prefix" value="pool.kafka.producer.configs"/>
            <property name="staticEnvironment">
                <map>
                    <entry key="bootstrap.servers" value="${pool.kafka.producer.bootstrap.servers}"/>
                    <entry key="key.serializer" value="org.apache.kafka.common.serialization.StringSerializer"/>
                    <entry key="value.serializer" value="org.dcache.notification.MoverInfoMessageSerializer"/>
                    <entry key="client.id" value="${pool.cell.name}@${dcache.domain.name}-transfer"/>
                </map>
            </property>
        </bean>



        <bean id="billing-template-transfer"  class="org.springframework.kafka.core.KafkaTemplate">
            <qualifier value="transfer"/>
            <constructor-arg>
                <bean class="org.springframework.kafka.core.DefaultKafkaProducerFactory">
                    <constructor-arg name="configs" ref ="kafka-configs-transfer"/>
                </bean>
            </constructor-arg>
            <constructor-arg name="autoFlush" value="false" />
            <property name="defaultTopic" value="${pool.kafka.topic}"/>
            <property name="producerListener" ref="listener"/>
        </bean>

    </beans>


    <beans profile="p2phttps-NEVER">

        <bean id="p2p" parent="p2p-parent">
            <description>Pool to pool transfer manager</description>
            <property name="tlsMode" value="${pool.enable.encrypted.p2p-transfers}"/>

        </bean>
    </beans>


    <beans profile="p2phttps-ALWAYS">

        <bean id="p2p" parent="p2p-parent">
            <description>Pool to pool transfer manager with encryption</description>
            <property name="sslContext" ref="jdk-ssl-context-builder"/>
            <property name="tlsMode" value="${pool.enable.encrypted.p2p-transfers}"/>
        </bean>

    </beans>

    <beans profile="p2phttps-CROSSZONES">

        <bean id="p2p" parent="p2p-parent">
            <description>Pool to pool transfer manager with encryption</description>
            <property name="sslContext" ref="jdk-ssl-context-builder"/>
            <property name="tlsMode" value="${pool.enable.encrypted.p2p-transfers}"/>
        </bean>

    </beans>

    <beans profile="httpsredirect-false">
        <bean id="transfer-services" parent="abstract-transfer-service">
            <description>Collection of transfer services</description>
        </bean>
    </beans>

    <beans profile="httpsredirect-true">
        <bean id="transfer-services" parent="abstract-transfer-service">
            <description>Collection of transfer services with https</description>
            <property name="factories">
                <map merge="true">
                    <entry key="Https-1" value-ref="https-transfer-service"/>
                </map>
            </property>
        </bean>

        <bean id="https-transfer-service" parent="http-transfer-service-parent" class="org.dcache.http.HttpsTransferService">
            <description>HTTPS transfer service</description>
            <property name="sslContext" ref="netty-ssl-context-builder" />
            <property name="portRange">
                <bean class="org.dcache.util.NettyPortRange">
                    <constructor-arg value="${pool.mover.https.port.min}"/>
                    <constructor-arg value="${pool.mover.https.port.max}"/>
                </bean>
            </property>
        </bean>
    </beans>

    <beans profile="inotify-true">
        <bean id="event-notifier" class="diskCacheV111.namespace.EventNotifier">
            <description>Service allowing other dCache components to be notified of namespace events</description>
            <property name="cellStub">
                <bean class="org.dcache.cells.CellStub">
                    <property name="timeout" value="10"/>
                    <property name="timeoutUnit" value="SECONDS"/>
                </bean>
            </property>

            <property name="dispatchExecutor">
                <bean class="org.dcache.util.BoundedCachedExecutor"
                      destroy-method="shutdownNow">
                    <constructor-arg value="1"/>  <!-- Only a single thread -->
                    <constructor-arg value="${pool.inotify-generation.backlog.initial}"/>
                </bean>
            </property>

            <property name="senderExecutor">
                <bean class="java.util.concurrent.Executors"
                      factory-method="newSingleThreadExecutor"
                      destroy-method="shutdownNow"/>
            </property>
            <property name="eventBatchSize"
                      value="${pool.inotify-generation.message-batch-size}"/>
            <property name="maximumQueuedEvents"
                      value="${pool.inotify-generation.backlog.per-door}"/>
        </bean>

	<bean id="notification-amplifier"
	      class="org.dcache.pool.repository.inotify.NotificationAmplifier">
	    <constructor-arg ref="event-notifier"/>
	</bean>

	<bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
	    <property name="targetObject" ref="rep"/>
	    <property name="targetMethod" value="addListener"/>
	    <property name="arguments" ref="notification-amplifier"/>
	</bean>

	<bean id="replica-store"
	      class="org.dcache.pool.repository.inotify.InotifyReplicaStore">
	    <constructor-arg ref="checksum-replica-store"/>
	    <constructor-arg ref="notification-amplifier"/>
	    <constructor-arg value="#{ T(org.dcache.util.TimeUtils).durationOf('${pool.inotify-generation.io-suppression}', '${pool.inotify-generation.io-suppression.unit}') }"/>
	</bean>
    </beans>

    <beans profile="inotify-false">
        <bean id="replica-store" parent="checksum-replica-store"/>
    </beans>

    <beans profile="account-checking-false">
      <bean id="account"
            class="org.dcache.pool.repository.Account">
	<description>Repository space accounting</description>
      </bean>
    </beans>

    <beans profile="account-checking-true">
      <bean id="account"
            class="org.dcache.pool.repository.FileTrackingAccount">
	<description>Repository space accounting</description>
      </bean>
    </beans>
</beans>
