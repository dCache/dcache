package org.dcache.cells;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

import diskCacheV111.util.CacheException;
import diskCacheV111.vehicles.Message;

import dmg.cells.nucleus.CellAdapter;
import dmg.cells.nucleus.CellAddressCore;
import dmg.cells.nucleus.CellEndpoint;
import dmg.cells.nucleus.CellMessage;
import dmg.cells.nucleus.CellMessageReceiver;
import dmg.cells.nucleus.Reply;
import dmg.cells.nucleus.UOID;

import org.dcache.util.Args;
import org.dcache.util.Option;
import org.dcache.util.OptionParser;

/**
 * Abstract cell implementation providing features needed by many
 * dCache cells.
 *
 * <h2>Automatic dispatch of dCache messages to message handler</h2>
 *
 * See org.dcache.util.CellMessageDispatcher for details.
 *
 * <h2>Initialisation</h2>
 *
 * AbstractCell provides the <code>init</code> method for performing
 * cell initialisation. This method is executed in a thread allocated
 * from the cells thread, and thus the thread group and log4j context
 * are automatically inherited for any threads created during
 * initialisation. Any log messages generated from within the
 * <code>init</code> method are correctly attributed to the
 * cell. Subclasses should override <code>init</code> rather than
 * performing initialisation steps in the constructor.
 *
 * The <code>init</code> method is called by <code>doInit</code>,
 * which makes sure <code>init</code> is executed in the correct
 * thread. <code>doInit</code> also enables cells message delivery by
 * calling <code>CellAdapter.start</code>. Should <code>init</code>
 * throw an exception, then <code>doInit</code> immediately kills the
 * cell and logs an error message.
 *
 * Subclasses must call doInit (preferably from their constructor) for
 * any of this to work.
 *
 * <h2>Option parsing</h2>
 *
 * AbstractCell supports automatic option parsing based on annotations
 * of fields. A field is annotated with the Option annotation. The
 * annotation supports the following attributes:
 *
 * <dl>
 * <dt>name</dt>
 * <dd>The name of the option.</dd>
 *
 * <dt>description</dt>
 * <dd>A one line description of the option.</dd>
 *
 * <dt>defaultValue</dt>
 * <dd>The default value if the option is not specified,
 * specified as a string.</dd>
 *
 * <dt>unit</dt>
 * <dd>The unit of the value, if any, e.g. seconds.</dd>
 *
 * <dt>required</dt>
 * <dd>Whether this is a mandatory option. Defaults to false.</dd>
 *
 * <dt>log</dt>
 * <dd>Whether to log the value of the option during startup.
 * Defaults to true, but should be disabled for sensitive
 * information.</dd>
 * </dl>
 *
 * Options are automatically converted to the type of the field. In
 * case of non-POD fields, the class must have a one-argument
 * constructor taking a String. The File class is an example of such a
 * class.
 *
 * By defaults options are logged at the info level. The description
 * and unit should be formulated in such a way that the a message can
 * be formed as "<description> set to <value> <unit>".
 *
 * In case a required option is missing, an IllegalArgumentException
 * is thrown during option parsing.
 *
 * It is important that fields used for storing options do not have an
 * initializer. An initializer would overwrite the value retrieved
 * from the option. Empty Strings will become null.
 *
 * Example code:
 *
 * <code>
 *   @Option(
 *       name = "maxPinDuration",
 *       description = "Max. lifetime of a pin",
 *       defaultValue = "86400000", // one day
 *       unit = "ms"
 *   )
 *   protected long _maxPinDuration;
 *
 * @see org.dcache.cells.CellMessageDispatcher
 */
public class AbstractCell extends CellAdapter implements CellMessageReceiver
{
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractCell.class);

    private static final String MSG_UOID_MISMATCH =
        "A reply [%s] was generated by a message listener, but the " +
        "message UOID indicates that another message listener has " +
        "already replied to the message.";
    private static final String MSG_REPLY_TO_REPLY =
        "A reply [%s] was generated by a message listener, but the " +
        "message was already a reply to which no reply can be sent.";
    private static final String MSG_ALREADY_FORWARDED =
        "A reply [%s] was generated by a message listener, but the " +
        "message was already forwarded and thus no reply can be sent.";
    private static final String MSG_NO_NEXT_DESTINATION =
        "A message [%s] was received for forwarding, but the message contains " +
        "no address to forward it to.";

    @Option(
        name = "monitor",
        description = "Cell message monitoring",
        defaultValue = "false"
    )
    protected boolean _isMonitoringEnabled;

    @Option(
        name = "cellClass",
        description = "Cell classification"
    )
    protected String _cellClass;

    private final OptionParser _optionParser;

    /**
     * Helper object used to dispatch messages to message listeners.
     */
    protected final CellMessageDispatcher _messageDispatcher =
        new CellMessageDispatcher("messageArrived");

    /**
     * Helper object used to dispatch messages to forward to message
     * listeners.
     */
    protected final CellMessageDispatcher _forwardDispatcher =
        new CellMessageDispatcher("messageToForward");

    /**
     * Name of context variable to execute during setup, or null.
     */
    protected String _definedSetup;

    protected MessageProcessingMonitor _monitor;

    /**
     * Strips the first argument if it starts with an exclamation
     * mark.
     */
    private static Args stripDefinedSetup(Args args)
    {
        args = new Args(args);
        if ((args.argc() > 0) && args.argv(0).startsWith("!")) {
            args.shift();
        }
        return args;
    }

    /**
     * Returns the defined setup declaration, or null if there is no
     * defined setup.
     *
     * The defined setup is declared as the first argument and starts
     * with an exclamation mark.
     */
    private static String getDefinedSetup(Args args)
    {
        if ((args.argc() > 0) && args.argv(0).startsWith("!")) {
            return args.argv(0).substring(1);
        } else {
            return null;
        }
    }

    /**
     * Returns the cell type specified as option 'cellType', or
     * "Generic" if the option was not given.
     */
    private static String getCellType(Args args)
    {
        String type = args.getOpt("cellType");
        return (type == null) ? "Generic" : type;
    }

    public AbstractCell(String cellName, String arguments)
    {
        this(cellName, new Args(arguments));
    }

    public AbstractCell(String cellName, Args arguments)
    {
        this(cellName, getCellType(arguments), arguments);
    }

    /**
     * Constructs an AbstractCell.
     *
     * @param cellName the name of the cell
     * @param cellType the type of the cell
     * @param arguments the cell arguments
     */
    public AbstractCell(String cellName, String cellType, Args arguments)
    {
        super(cellName, cellType, stripDefinedSetup(arguments));
        _definedSetup = getDefinedSetup(arguments);
        _optionParser = new OptionParser(arguments);
    }

    /**
     * Performs cell initialisation and starts cell message delivery.
     *
     * Initialisation is delegated to the <code>init</code> method,
     * and subclasses should perform initilisation by overriding
     * <code>init</code>. If the <code>init</code> method throws an
     * exception, then the cell is immediately killed.
     *
     * @throws InterruptedException if the thread was interrupted
     * @throws ExecutionException if init threw an exception
     */
    protected final void doInit()
        throws InterruptedException, ExecutionException
    {
        try {
            /* Execute initialisation in a different thread allocated
             * from the correct thread group.
             */
            Callable<Void> task = new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                    _optionParser.inject(AbstractCell.this);

                    _monitor = new MessageProcessingMonitor();
                    _monitor.setCellEndpoint(AbstractCell.this);
                    _monitor.setEnabled(_isMonitoringEnabled);

                    if (_cellClass != null) {
                        getNucleus().setCellClass(_cellClass);
                    }

                    addMessageListener(AbstractCell.this);
                    addCommandListener(_monitor);

                    AbstractCell.this.executeInit();
                    return null;
                }
            };
            invokeOnMessageThread(task).get();

            start();
        } catch (InterruptedException e) {
            LOGGER.info("Cell initialisation was interrupted.");
            start();
            kill();
            throw e;
        } catch (ExecutionException e) {
            start();
            kill();
            throw e;
        } catch (RuntimeException e) {
            // A stacktrace from a RuntimeException is printed in Bootloader
            start();
            kill();
            throw e;
        }
    }

    /**
     * Called from the initialization thread. By default the method
     * first calls the <code>executeDefinedSetup</code> method,
     * followed by the <code>init</code> method and the
     * <code>startTimeoutTask</code> method. Subclasses may override
     * this behaviour if they wish to modify when the defined setup is
     * executed.
     */
    protected void executeInit()
        throws Exception
    {
        executeDefinedSetup();
        init();
    }

    /**
     * Executes the defined setup (specified with !variable in the
     * argument string).
     *
     * By default, this method is called from
     * <code>executeInit</code>.
     */
    protected void executeDefinedSetup()
    {
        if (_definedSetup != null) {
            executeDomainContext(_definedSetup);
        }
    }

    /**
     * Initialize cell. This method should be overridden in subclasses
     * to perform cell initialization.
     *
     * The method is called from the <code>executeInit</code> method,
     * but using a thread belonging to the thread group of the
     * associated cell nucleus. This ensures correct logging and
     * correct thread group inheritance.
     *
     * It is valid for the method to call
     * <code>CellAdapter.start</code> if early start of message
     * delivery is needed.
     */
    protected void init() throws Exception {}

    /**
     * Returns the friendly cell name used for logging. It defaults to
     * the cell name.
     */
    protected String getFriendlyName()
    {
        return getCellName();
    }

    public void debug(String str)
    {
        LOGGER.debug(str);
    }

    public void debug(Throwable t)
    {
        LOGGER.debug(t.getMessage());
        StringWriter sw = new StringWriter();
        t.printStackTrace(new PrintWriter(sw));
        for (String s : sw.toString().split("\n")) {
            LOGGER.debug(s);
        }
    }

    /**
     * Adds a listener for dCache messages.
     *
     * @see CellMessageDispatcher#addMessageListener
     */
    public void addMessageListener(CellMessageReceiver o)
    {
        _messageDispatcher.addMessageListener(o);
        _forwardDispatcher.addMessageListener(o);
    }

    /**
     * Removes a listener previously added with addMessageListener.
     */
    public void removeMessageListener(CellMessageReceiver o)
    {
        _messageDispatcher.removeMessageListener(o);
        _forwardDispatcher.removeMessageListener(o);
    }

    /**
     * Sends a reply back to the sender of <code>envelope</code>.
     */
    private void sendReply(CellEndpoint endpoint, CellMessage envelope, Object result)
    {
        Serializable o = envelope.getMessageObject();
        if (o instanceof Message) {
            Message msg = (Message)o;

            /* Don't send reply if not requested. Some vehicles
             * contain a bug in which the message is marked as not
             * requiring a reply, while what was intended was
             * asynchronous processing on the server side. Therefore
             * we have a special test for Reply results.
             */
            if (!msg.getReplyRequired() && !(result instanceof Reply)) {
                return;
            }

            /* dCache vehicles can transport errors back to the
             * requestor, so detect if this is an error reply.
             */
            if (result instanceof CacheException) {
                CacheException e = (CacheException)result;
                msg.setFailed(e.getRc(), e.getMessage());
                result = msg;
            } else if (result instanceof IllegalArgumentException) {
                msg.setFailed(CacheException.INVALID_ARGS,
                              result.toString());
                result = msg;
            } else if (result instanceof Exception) {
                msg.setFailed(CacheException.UNEXPECTED_SYSTEM_EXCEPTION,
                        (Exception) result);
                result = msg;
            }
        }

        if (result instanceof Reply) {
            Reply reply = (Reply)result;
            reply.deliver(endpoint, envelope);
        } else {
            envelope.revertDirection();
            envelope.setMessageObject((Serializable) result);
            endpoint.sendMessage(envelope);
        }
    }

    /**
     * Delivers message to registered forward listeners.
     *
     * A reply is delivered back to the client if any message
     * listener:
     *
     * - Returns a value
     *
     * - Throws a checked exception, IllegalStateException or
     *   IllegalArgumentException.
     *
     * dCache vehicles (subclasses of Message) are recognized, and
     * a reply is only sent if requested by the client.
     *
     * For dCache vehicles, errors are reported by sending back the
     * vehicle with an error code. CacheException and
     * IllegalArgumentException are recognised and an appropriate
     * error code is used.
     *
     * Return values implementing Reply are recognized and the reply
     * is delivered by calling the deliver method on the Reply object.
     *
     * If no listener returns a value or throws Throws a checked
     * exception, IllegalStateException or IllegalArgumentException,
     * and the UOID of the envelope is unaltered, then the message is
     * forwarded to the next destination.
     */
    @Override
    public void messageToForward(CellMessage envelope)
    {
        CellEndpoint endpoint = _monitor.getReplyCellEndpoint(envelope);
        UOID uoid = envelope.getUOID();
        CellAddressCore address = envelope.getDestinationPath().getCurrent();
        boolean isReply = isReply(envelope);
        Object result = _forwardDispatcher.call(envelope);

        if (result != null) {
            if (isReply) {
                throw new RuntimeException(String.format(MSG_REPLY_TO_REPLY, result));
            }
            if (!uoid.equals(envelope.getUOID())) {
                throw new RuntimeException(String.format(MSG_UOID_MISMATCH, result));
            }
            if (!address.equals(envelope.getDestinationPath().getCurrent())) {
                throw new RuntimeException(String.format(MSG_ALREADY_FORWARDED, result));
            }
            sendReply(endpoint, envelope, result);
        } else if (address.equals(envelope.getDestinationPath().getCurrent())) {
            if (!envelope.nextDestination()) {
                throw new RuntimeException(String.format(MSG_NO_NEXT_DESTINATION, envelope));
            }
            endpoint.sendMessage(envelope);
        }
    }

    private boolean isReply(CellMessage envelope)
    {
        Object message = envelope.getMessageObject();
        return (message instanceof Message) && ((Message) message).isReply();
    }

    /**
     * Delivers messages to registered message listeners.
     *
     * A reply is delivered back to the client if any message
     * listener:
     *
     * - Returns a value
     *
     * - Throws a checked exception, IllegalStateException or
     *   IllegalArgumentException.
     *
     * dCache vehicles (subclasses of Message) are recognized, and
     * a reply is only sent if requested by the client.
     *
     * For dCache vehicles, errors are reported by sending back the
     * vehicle with an error code. CacheException and
     * IllegalArgumentException are recognised and an appropriate
     * error code is used.
     *
     * Return values implementing Reply are recognized and the reply
     * is delivered by calling the deliver method on the Reply object.
     */
    @Override
    public void messageArrived(CellMessage envelope)
    {
        CellEndpoint endpoint = _monitor.getReplyCellEndpoint(envelope);
        UOID uoid = envelope.getUOID();
        boolean isReply = isReply(envelope);
        Object result = _messageDispatcher.call(envelope);

        if (result != null && !isReply) {
            if (!uoid.equals(envelope.getUOID())) {
                throw new RuntimeException(String.format(MSG_UOID_MISMATCH, result));
            }
            sendReply(endpoint, envelope, result);
        }
    }
}
