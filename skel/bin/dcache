#!/bin/sh
#
# chkconfig: 2345 92 8
# description: dCache init script

set -e

# Solaris doesn't have a POSIX compliant shell as /bin/sh. We
# try to find one and execute it.
if [ "$1" = "%" ]; then
    shift
elif [ "`uname`" = "SunOS" ]; then
    if [ -x /usr/xpg4/bin/sh ]; then
        exec /usr/xpg4/bin/sh $0 % "$@"
    elif [ -x /bin/bash ]; then
        exec /bin/bash $0 % "$@"
    else
        echo "Cannot find POSIX compliant shell. This script will"
        echo "probably break, but we attempt to execute it anyway."
    fi
fi

# Prints help screen and exits with error status 2
usage()
{
    echo "Usage: $(basename $0) [OPTION]... COMMAND"
    echo
    echo "Valid options are:"
    echo "   -d=<path to dcache installation>   default is /opt/d-cache"
    echo
    echo "Valid commands are:"
    echo "   condrestart [<domain> ...]"
    echo "   dump heap [--force] <domain> <file>"
    echo "   dump threads [<domain> ...]"
    echo "   import hostcert [--hostcert=<file>] [--hostkey=<file>]"
    echo "                   [--out=<file>] [--password=<password>]"
    echo "   import cacerts [--cacerts=<dir>] [--out=<file>] [--password=<password>]"
    echo "   pool create <size> <directory>"
    echo "   pool reconstruct <directory> <target dir>"
    echo "   restart [<domain> ...]"
    echo "   start [<domain> ...]"
    echo "   status"
    echo "   stop [<domain> ...]"
    echo "   version"
    echo
    echo "Size is specified in bytes, or optionally followed by K, M, G or T"
    echo "for powers of 1024. Size is rounded down to the nearest integer "
    echo "number of GiB."
    exit 2
} 1>&2

# Get the canonical path of $1. Only returns a truly canonical path
# if readlink is available. Otherwise an absolute path which does not
# end in a symlink is returned.
getCanonicalPath() # in $1 = path, out $2 = canonical path
{
    local link
    local ret
    link="$1"
    if readlink -f . > /dev/null 2>&1; then
	ret="$(readlink -f $link)"
    else
        ret="$(cd $(dirname $link); pwd)/$(basename $link)"
        while [ -h "$ret" ]; do
            link="$(ls -ld $ret | sed 's/.*-> //')"
            if [ -z "${link##/*}" ]; then
                ret="${link}"
            else
                link=$(dirname $ret)/${link}
                ret="$(cd $(dirname $link); pwd)/$(basename $link)"
            fi
        done
    fi
    eval $2=\"$ret\"
}

# Returns true if $1 is contained as a word in $2.
contains() # in $1 = word, in $2+ = list
{
    local word
    word=$1
    shift
    for i in "$@"; do
        if [ "$word" = "$i" ]; then
            return 0
        fi
    done
    return 1
}

# Generic option parser. Both single and multi character options are
# supported. Single character options start with a single dash and
# multi character options with a double dash. Single character options
# can be combined, e.g. rather than -a -b -c one can use -abc.
#
# The first argument is a list of valid options. Remaining arguments
# are the options to be parsed. When finding an option not in the list
# of valid options, the usage() is called.
#
# Parsing stops when no arguments are left or a non-option argument
# is found.
#
# Options can have an optional value.
#
# For each option found the variable opt_X, where X is the
# option, is defined. If a value is provided for the option, then
# opt_X is set to that value, otherwise to 1.
#
# The return value is the number of words of $1 that were processed.
#
parseOptions() # $1 = list of valid options
{
    local valid
    local count
    local name
    local value
    local rest
    local option

    valid=$1
    count=0

    shift
    while [ $# -gt 0 ]; do
        option=$1
        case $option in
            --*=*)
                option=${option#--}    # Strip leading double dash
                name=${option%%=*}
                value=${option#*=}
                ;;

            -?=*)
                option=${option#-}     # Strip leading dash
                name=${option%%=*}
                value=${option#*=}
                ;;

            --?*)
                name=${option#--}      # Strip leading double dash
                value=1
                ;;

            -?*)
                option=${option#-}     # Strip leading dash
                while [ -n "$option" ]; do
                    rest=${option#?}       # Strip leading character
                    name=${option%${rest}} # Strip the rest to get name
                    if ! contains $name $valid; then
                        usage
                    fi

                    option=${rest}

                    eval "opt_${name}=1"
                done
                count=$((${count}+1))
                shift
                continue
                ;;

            *)
                break
                ;;
        esac

        if ! contains $name $valid; then
            usage
        fi

        eval "opt_${name}=${value}"

        shift
        count=$((${count}+1))
    done

    return $count
}

# Dumps the heap. Terminates the script in case of failure.
dumpHeap() # $1=force, $2=live, $3=file, $4=pid, $5=error
{
    if ! $jmap ${1:+-F} -dump:${2:+live,}format=b,file=$3 $4; then
        fail 1 "$5"
    fi

    if [ ! -f "$3" ]; then
        fail 1 "$5"
    fi
}

# display dCache package version
showVersion()
{
    "$JAVA" -jar ${classesDir}/dcache.jar
}


loadDomainConfiguration() # $1 = domain
{
    DOMAIN="$1"
    loadConfig "dcache.*"
}

# Parse global options
parseOptions "d" "$@" || shift $?

if [ $# -eq 0 ]; then
    usage
fi

# Initialize environment. /etc/default/ is the normal place for this
# on several Linux variants. For other systems we provide
# /etc/dcache.env. Those files will typically declare JAVA_HOME and
# DCACHE_HOME and nothing else.
[ -f /etc/default/dcache ] && . /etc/default/dcache
[ -f /etc/dcache.env ] && . /etc/dcache.env

# Set home path
if [ -n "$opt_d" ]; then
    DCACHE_HOME="$opt_d"
elif [ -z "$DCACHE_HOME" ]; then
    getCanonicalPath "$0" path
    DCACHE_HOME="${path%/bin/dcache}"
fi

if [ ! -d "$DCACHE_HOME" ]; then
    echo "$DCACHE_HOME is not a directory"
    exit 2
fi

ourHomeDir="${DCACHE_HOME}"   # We still use ourHomeDir in some places

# Load libraries
. ${DCACHE_HOME}/share/lib/paths.sh
. ${DCACHE_LIB}/utils.sh
. ${DCACHE_LIB}/services2.sh
. ${DCACHE_LIB}/pool.sh

# Check prerequisites
require awk df egrep grep sed cat hostname wc dirname basename mount mv tr which

# Check for java
if ! findJavaTool java || [ ! -x "${java}" ] || ! "$java" -version 2>&1 | egrep -e 'version "1\.[6]' >/dev/null ; then
    fail 1 "Could not find usable Java VM. Please set JAVA_HOME to
            the path to Java 6 or newer."
fi
JAVA="$java"

determineHostName

case "$1" in
    start)
        shift
        domains=$(printDomains "$@")

        for domain in $domains; do
	    (
		loadDomainConfiguration "$domain"
                domainStart || :
	    )
        done

        touch $DCACHE_LOCK 2> /dev/null || :
        ;;

    stop)
        shift
        domains=$(printDomains "$@")

        reverse domains_backward $domains
        for domain in $domains_backward; do
	    (
		loadDomainConfiguration "$domain"
		if pid=$(printDaemonPid); then
                    domainStop || :
		fi
            )
        done

        rm -f $DCACHE_LOCK
        ;;

    restart)
        shift
        domains=$(printDomains "$@")

        reverse domains_backward $domains
        for domain in $domains_backward; do
	    (
		loadDomainConfiguration "$domain"
                if pid=$(printDaemonPid); then
                    domainStop || :
		fi
	    )
        done

        for domain in $domains; do
	    (
		loadDomainConfiguration "$domain"
                domainStart || :
            )
        done
        ;;

    condrestart)
        shift
        domains=$(printDomains "$@")

        reverse domains_backward $domains
        for domain in $domains_backward; do
	    (
		loadDomainConfiguration "$domain"
		if pid=$(printDaemonPid); then
		    running_domains="$running_domains $domain"
                    domainStop
		fi
	    )
        done

        reverse domains_to_start $running_domains
        for domain in $domains_to_start; do
	    (
		loadDomainConfiguration "$domain"
		domainStart
            )
        done
        ;;

    status)
        domains=$(printDomains "*")
        maxWidth width $domains
        format="%-${width}s %-10s %5s\n"
        printf "$format" "Domain" "Status" "PID"
        for domain in $domains; do
	    (
		loadDomainConfiguration "$domain"
		status=$(printDomainStatus)
		pid=$(printJavaPid) || :
		printf "$format" "$domain" "$status" "$pid"
            )
        done
        ;;

    version)
        showVersion
	;;

    pool)
        shift

        if [ $# -eq 0 ]; then
            usage
        fi

        command=$1
        shift

        case "$command" in
            create)
                [ $# -ne 2 ] && usage

                size=$1
                path=$2

                createPool ${size} ${path}
                ;;

            reconstruct)
                [ $# -ne 2 ] && usage
                src="$1"
                dst="$2"

                # Check that we have a meta directory
                if [ ! -d "$src/meta" ]; then
                    fail 2 "The pool appears not to have a Berkeley DB holding
                            the meta data, as there is no $src/meta directory."
                fi

                # Make sure the destination does not exist
                if [ -e "$dst" ]; then
                    fail 2 "$dst already exists. The target directory must"
                           "not exist prior to recovering a pool."
                fi

                # Reconstruct the DB
                mkdir -p "$dst" || fail 1 "Failed to create $dst"
                reconstructMeta "${src}/meta" "${dst}" || fail 1 "Operation aborted"

                printp "The pool meta data database of $src was reconstructed
                        and stored in $dst. You have to manually replace
                        $src/meta with the content of $dst."
                ;;

            *)
                usage
                ;;
        esac

        ;;

    dump)
        shift

        if [ $# -eq 0 ]; then
            usage
        fi

        command=$1
        shift

        case "$command" in
            heap)
                parseOptions "force" "$@" || shift $?

                [ $# -ne 2 ] && usage

                (
		    loadDomainConfiguration "$1"

                    file=$2

                    findJavaTool jmap ||
                    fail 1 "Could not find the jmap command, part of the Java 6
                            JDK. This command is required for producing a heap
                            dump. Please ensure that either jmap is in the path
                            or update JAVA_HOME."

                    if [ -f ${file} ]; then
                        fail 1 "${file} already exists. Heap not dumped."
                    fi

                    if ! pid=$(printJavaPid); then
                        fail 1 "Domain ${DOMAIN} is not running."
                    fi

                    if [ -z "$opt_force" ]; then
                        dumpHeap "" "live" "$file" "$pid" \
                            "Failed to dump the heap; please consult
                             the previous error message for possible
                             reasons. The dump might succeed when using
                             the --force option."
                    else
                        dumpHeap "force" "" "$file" "$pid" \
                            "Failed to dump the heap; please consult
                             the previous error message for possible
                             reasons."
                    fi

                    printp "The heap of domain ${DOMAIN} has been written to
                            ${file}. Notice that the file might contain
                            confidential information."
                )
                ;;

            threads)
                for domain in $(printDomains "$@"); do
	            (
		        loadDomainConfiguration "$domain"
                        if pid=$(printJavaPid); then
                            if ! kill -s QUIT "${pid}"; then
                                fail 1 "Failed to dump stack traces. Likely
                                        the current user does not have the
                                        proper permissions."
                            fi
                            printp "Stack traces for $domain have been written to $DCACHE_LOG_FILE."
                        fi
                    )
                done
                ;;

            *)
                usage
                ;;
        esac
        ;;

    import)
        shift

        if [ $# -eq 0 ]; then
            usage
        fi

        command=$1
        shift

        case "$command" in
            hostcert)
                require openssl

                opt_password="${DCACHE_KEYSTOREPASSWORD:-dcache}"
                opt_out="${DCACHE_KEYSTORE:-${DCACHE_HOME}/etc/hostcert.p12}"
                opt_hostcert="/etc/grid-security/hostcert.pem"
                opt_hostkey="/etc/grid-security/hostkey.pem"

                parseOptions "out password hostcert hostkey" "$@" || shift $?

                PASSWORD="${opt_password}" openssl pkcs12 -export -in "$opt_hostcert" -inkey "$opt_hostkey" -out "$opt_out" -passout env:PASSWORD && chmod 400 "$opt_out" || exit
                printp "The host certifcate has been stored in $opt_out. If
                        dCache runs as a non-root user, you must change
                        the owner of $opt_out."
                ;;

            cacerts)
                require openssl
                findJavaTool keytool ||
                fail 1 "Could not find the keytool command, part of the Java
                        JRE. Please ensure that either keytool is in the path
                        or update JAVA_HOME."

                opt_password="${DCACHE_TRUSTSTOREPASSWORD:-dcache}"
                opt_out="${DCACHE_TRUSTSTORE:-${DCACHE_HOME}/etc/certificates.jks}"
                opt_cacerts="/etc/grid-security/certificates"

                parseOptions "out password cacerts" "$@" || shift $?

                rm -f "${opt_out}" || exit

                for cert in $opt_cacerts/*.0; do
                    base="${cert%.0}"
                    readconf "${file}.info" cert_ || cert_alias=$(basename "${base}")
                    printf "$cert_alias "
                    openssl x509 -in "${cert}" | ${keytool} -importcert -noprompt -alias "${cert_alias}" -storepass "${opt_password}" -keystore "${opt_out}" > /dev/null || exit
                done
                ;;

            *)
                usage
                ;;
        esac
        ;;

    *)
        usage
        ;;
esac
