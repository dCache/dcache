#!/bin/sh
#
# chkconfig: 2345 92 8
# description: dCache init script

LOCK_FILE=/var/lock/subsys/dcache

# Solaris doesn't have a POSIX compliant shell as /bin/sh. We
# try to find one and execute it.
if [ "$1" = "%" ]; then
    shift
elif [ "$(uname)" = "SunOS" ]; then
    if [ -x /usr/xpg4/bin/sh ]; then
	exec /usr/xpg4/bin/sh $0 % $*
    elif [ -x /bin/bash ]; then
	exec /bin/bash $0 % $*
    else
	echo "Cannot find POSIX compliant shell. This script will"
	echo "probably break, but we attempt to execute it anyway."
    fi
fi

# Prints help screen and exits with error status 2
usage() 
{
    echo "Usage: $(basename $0) [OPTION]... COMMAND"
    echo 
    echo "Valid options are:"
    echo "   -d=<path to dcache installation>   default is /opt/d-cache"
    echo    
    echo "Valid commands are:"
    echo "   dump heap <domain> <file>"
    echo "   dump threads [ <domain or service> ... ]"
    echo "   pool create <size> <directory>"
    echo "   pool add [ --fqdn ] [ --domain=<domain> ] <pool name> <directory>"
    echo "   pool ls"
    echo "   pool remove <pool name>"
    echo "   restart [ <domain or service> ... ]"
    echo "   services"
    echo "   start [ <domain or service> ... ]"
    echo "   status"
    echo "   stop [ <domain or service> ... ]"
    echo
    echo "Size is specified in bytes, or optionally followed by K, M, G or T"
    echo "for powers of 1024. Size is rounded down to the nearest integer "
    echo "number of GiB."
#    echo "   version"
    exit 2
} 1>&2

# Returns true if $1 is contained as a word in $2.
contains() # $1 = word, $2 = list
{
    local word
    word=$1
    shift
    for i in "$@"; do 
	if [ "$word" = "$i" ]; then
	    return 0
	fi
    done
    return 1
}

# Reverses a list of words
reverse() # $1 = space delimited list of words
{
    RET=''
    for s in $*; do
        RET="${s} ${RET}"
    done
}

# Normalises a path such that it does not contain double or trailing
# slashes.
sanitisePath() # $1 = path
{
    RET=$(echo $1 | sed -e 's_//*_/_g' -e 's_/$__')
}

# Returns the maximum width of any word in a given list.
max_width() # $* = list of words
{
    local max
    local width

    max=0
    for i in $*; do 
        width=${#i}
        if [ $max -lt $width ]; then
            max=$width
        fi
    done

    RET=$max
}

# Utility function for printing to stdout with a line width 
# maximum of 75 characters. Longer lines are broken into several
# lines. Each argument is interpreted as a separate paragraph.  
printp() # $* = list of paragraphs
{
    local line
    local line2

    while [ $# -gt 0 ]; do
	# If line is non empty, then we need to print a 
	# paragraph separator.
	if [ -n "$line" ]; then
	    echo
	fi
	line=
	for word in $1; do
	    line2="$line $word"
	    if [ ${#line2} -gt 75 ]; then
		echo $line
		line=$word
	    else
		line=$line2
	    fi
	done
	echo $line
	shift
    done
}

# Prints an error message to stderr and exist with status $1
fail() # $1 = exit status, $2- = list of paragraphs, see printp
{
    local n
    n=$1
    shift
    printp "$@"
    exit $n
} 1>&2

# Returns 0 if the given file is empty, 1 otherwise. The file must
# exist.
isFileEmpty() # $1 = file
{
    if [ $(wc -l < $1) -eq 0 ]; then
        return 0;
    else
        return 1;
    fi
}

# Generic option parser. Both single and multi character options are
# supported. Single character options start with a single dash and
# multi character options with a double dash. Single character options
# can be combined, e.g. rather than -a -b -c one can use -abc.
#
# The first argument is a list of valid options. Remaining arguments 
# are the options to be parsed. When finding an option not in the list
# of valid options, the usage() is called.
#
# Parsing stops when no arguments are left or a non-option argument 
# is found.
#
# Options can have an optional value. 
#
# For each option found the variable opt_X, where X is the 
# option, is defined. If a value is provided for the option, then 
# opt_X is set to that value, otherwise to 1.
# 
# The return value is the number of words of $1 that were processed.
#
parseOptions() # $1 = list of valid options
{
    local valid
    local count
    local name
    local value
    local rest
    local option

    valid=$1
    count=0

    shift
    while [ $# -gt 0 ]; do
        option=$1
	case $option in
	    --*=*)
		option=${option#--}    # Strip leading double dash
		name=${option%%=*}
		value=${option#*=}
		;;

	    -?=*)
	        option=${option#-}     # Strip leading dash
		name=${option%%=*}
		value=${option#*=}
		;;

	    --?*)
		name=${option#--}      # Strip leading double dash
		value=1
		;;

	    -?*)
		option=${option#-}     # Strip leading dash
		while [ -n "$option" ]; do
		    rest=${option#?}       # Strip leading character
		    name=${option%${rest}} # Strip the rest to get name
		    if ! contains $name $valid; then
			usage
		    fi

		    option=${rest}

		    eval "opt_${name}=1"
		done
		count=$((${count}+1))
		shift
		continue
		;;
		
	    *)
		break
		;;
	esac

	if ! contains $name $valid; then
	    usage
	fi

	eval "opt_${name}=${value}"

	shift
	count=$((${count}+1))
    done

    return $count
}

# Retrieves setting from configuration file, $1 = parameter name
getConfig() 
{
    #               Comments      Trailing space       Print value
    #               vvvvvvvv      vvvvvvvvvvvvvvvv     vvvvvvvvvvvvvvvvvvvvvvvvv
    RET=$(sed -n -e 's/#.*$//' -e 's/[       ]*$//' -e "s/^[         ]*$1[   ]*=[    ]*\(.*\)$/\1/p" ${ourHomeDir}/etc/node_config ${ourHomeDir}/etc/door_config 2> /dev/null)
}

# Returns 0 if feature is enabled in node_config or door_config, 1
# otherwise
isEnabled() # $1 = option name
{
    getConfig $1; 
    case "$(echo $RET | tr '[A-Z]' '[a-z]')" in
        yes|y)
            return 0;
            ;;
        *)
            return 1;
            ;;
    esac
}

# Auto mount PNFS on FTP doors and check that PNFS in mounted on admin
# nodes.
autoMountNameSpace()
{
    local ADMIN_NODE
    local PNFS_ROOT
    local NODE_TYPE
    local NAMESPACE
    local SERVER_ID

    getConfig NAMESPACE; NAMESPACE=$RET
    if [ -z "$NAMESPACE" ] || [ "$NAMESPACE" = pnfs ]; then
        getConfig SERVER_ID; SERVER_ID=$RET
        if [ -z "${SERVER_ID}" ]; then
            SERVER_ID=$domainname
            if [ -z "${SERVER_ID}" ]; then
                SERVER_ID=$(sed -e 's/#.*$//' /etc/resolv.conf | awk '/^[ \t]*search/ { print $2 }')
                if [ -z "${SERVER_ID}" ]; then
                    SERVER_ID=$(sed -e 's/#.*$//' /etc/resolv.conf | awk '/^[ \t]*domain/ { print $2 }')
                fi
            fi
        fi

        getConfig PNFS_ROOT; PNFS_ROOT=$RET
        getConfig NODE_TYPE; NODE_TYPE=$RET
	if [ "$NODE_TYPE" = admin ]; then
	    if ! df ${PNFS_ROOT}/fs 2>/dev/null | grep -v "$PNFS_ROOT" > /dev/null; then
		fail 1 "${PNFS_ROOT}/fs mount point exists, but is
                        not mounted. Make sure pnfs is running on this 
                        admin node."
	    fi
	elif isEnabled GRIDFTP || isEnabled SRM ; then
	    if ! df ${PNFS_ROOT}/${SERVER_ID} 2>/dev/null | grep "$PNFS_ROOT" > /dev/null; then
		getConfig ADMIN_NODE; ADMIN_NODE=$RET
		if [ -z "$ADMIN_NODE" ] || [ "$ADMIN_NODE" = myAdminNode ]; then
		    fail 1 "PNFS not mounted on 
                            ${PNFS_ROOT}/${SERVER_ID}/ and ADMIN_NODE in 
                            etc/node_config or etc/door_config not set
                            properly."
		fi

                # Solaris specific fix
                case $(uname) in
                    SunOS)
                        NFSVERS=vers
                        ;;
                    *)
                        NFSVERS=nfsvers
                        ;;
                esac 

		printp "${PNFS_ROOT}/${SERVER_ID}/ not mounted - going to mount it now."
		mount -o intr,rw,noac,hard,${NFSVERS}=2 $ADMIN_NODE:/pnfsdoors ${PNFS_ROOT}/${SERVER_ID}
		if ! df ${PNFS_ROOT}/${SERVER_ID} 2>/dev/null | grep "$PNFS_ROOT"; then
		    fail 1 "Still not mounted. Apparently no PNFS
                            server running on admin node $ADMIN_NODE."
		fi
	    fi
	fi	
    fi
}

# Prints the service name of a domain. The service name corresponds to
# the name of the batch file of that service, without the file
# suffix. 
getService() # $1 = domain name
{
    if contains $1 $(getAllPoolDomains); then
	printf "pool"
    else
	case "$1" in
            dcap*-*Domain)
		printf "dcap"
		;;
            
            gPlazma-*Domain)
		printf "gPlazma"
		;;
            
            xrootd-*Domain)
		printf "xrootd"
		;;
            
            gridftp-*Domain)
		printf "gridftp"
		;;
            
            gsidcap-*Domain)
		printf "gsidcap"
		;;
	    
	    srm-*Domain)
		printf "srm"
		;;
	    
            *Domain)
		printf "%s" "${1%Domain}"
		;;
	    
            *)
		;;
	esac
    fi
}

# Prints list of configured services.
getServices()
{
    getConfig NODE_TYPE
    case "${RET}" in 
        admin)
            printf "lm dCache "

            getConfig NAMESPACE
            case "$RET" in
                chimera)
                    printf "chimera "
                    ;;
                *)
                    printf "pnfs "
                    ;;
            esac

            printf "dir admin httpd utility gPlazma "

            if isEnabled infoProvider; then
                printf "infoProvider "
            fi
            if isEnabled info; then
                printf "info "
            fi
            if isEnabled statistics; then
                printf "statistics "
            fi
            ;;
        custom)
            if isEnabled lmDomain; then
                printf "lm "
            fi
            if isEnabled poolManager; then
                printf "dCache "
            fi
            if isEnabled pnfsManager; then
                getConfig NAMESPACE
                case "$RET" in
                    chimera)
                        printf "chimera "
                        ;;
                    *)
                        printf "pnfs "
                        ;;
                esac
            fi
            if isEnabled dirDomain; then
                printf "dir "
            fi
            if isEnabled adminDoor; then
                printf "adminDoor "
            fi
            if isEnabled httpDomain; then
                printf "httpd "
            fi
            if isEnabled utilityDomain; then
                printf "utility "
            fi
            if isEnabled infoProvider; then
                printf "infoProvider "
            fi
            if isEnabled info; then
                printf "info "
            fi
            if isEnabled statistics; then
                printf "statistics "
            fi
            if isEnabled gPlazmaService; then
                printf "gPlazma "
            fi
            ;;
    esac    
    
    if [ -n "$(getDomains pool)" ]; then
	printf "pool "
    fi
    if isEnabled replicaManager; then
        printf "replica "
    fi
    if isEnabled DCAP; then
        printf "dcap "
    fi
    if isEnabled XROOTD; then
        printf "xrootd "
    fi	
    if isEnabled GRIDFTP; then
        printf "gridftp "
    fi
    if isEnabled GSIDCAP; then
        printf "gsidcap "
    fi
    if isEnabled SRM; then
        printf "srm "
    fi
}

# Prints all domains for the given service. Services like 'pool' and
# 'dcap' may have more than one domain. 
getDomains() # $1 = service
{
    local i
    local door

    case "$1" in
        dcap)
            for i in ${config}/door*Setup; do
                door=$(echo $i | sed -e "s#.*door\(.*\)Setup#\1#")
                printf "%s" "dcap${door}-${hostname}Domain "
            done 
            ;;
        
        gPlazma)
            printf "%s" "gPlazma-${hostname}Domain "
            ;;
        
        xrootd)
            printf "%s" "xrootd-${hostname}Domain "
            ;;
        
        gridftp)
            printf "%s" "gridftp-${hostname}Domain "
            ;;
        
        gsidcap)
            printf "%s" "gsidcap-${hostname}Domain "
            ;;

	srm)
	    printf "%s" "srm-${hostname}Domain "
	    ;;

	pool)
	    for i in $(getAllPoolDomains); do 
                if ! isFileEmpty $(getPoolListFile $i); then
                    printf "%s" "$i "
                fi
            done
	    ;;

        *Domain)
            printf "%s" "$1 "
            ;;
        
        *)
            printf "%s" "${1}Domain "
            ;;
    esac
}

# Prints all configured domains
getAllDomains()
{
    for service in $(getServices); do
        getDomains $service
    done
}

# Given a mixed list of domains and services, prints all domains for
# those services and domains. I.e. the domains are printed literally,
# and the services are expanded to the list of domains for those
# services. If no arguments are specified, a list of all configured
# domains is printed. 
expandServiceAndDomainList() # $* = list of services and domains
{
    if [ $# -eq 0 ]; then
        getAllDomains
    else
        for s in $*; do
            getDomains $s
        done
    fi
}

# Starts or stops a given domain. 
run() # $1 = domain, $2 = action
{
    local domain
    local action
    local service
    local program
    local door

    domain=$1
    action=$2
    service=$(getService $1)

    # Translate service name to name of control script
    case ${service} in
        srm)
            program="${ourHomeDir}/bin/dcache-srm"
            ;;
        dcap)
	    # $domain has the format 'dcap${door}-${host}Domain'
	    door=${domain#dcap}
	    door=${door%-${hostname}Domain}
            program="${ourHomeDir}/jobs/door${door}"
            ;;
        xrootd)
            program="${ourHomeDir}/jobs/xrootdDoor"
            ;;
	gridftp)
            program="${ourHomeDir}/jobs/gridftpdoor"
            ;;	    
	gsidcap)
            program="${ourHomeDir}/jobs/gsidcapdoor"
            ;;	    
	adminDoor)
            program="${ourHomeDir}/jobs/adminDoor"
            ;;
        *)
	    program="${ourHomeDir}/jobs/${service}"
            ;;
    esac

    if [ ! -x $program ]; then
	fail 1 "$program not found. The dCache domain $domain is 
                probably not configured on this host. If you recently
                configured it, then you may need to rerun the 
                install.sh script to enable it."
    fi

    case ${service} in
	pool)
	    ${program} -pool=${domain%Domain} ${logParam} ${action}
	    ;;
	srm)
	    ${program} ${action}
	    ;;
	*)
	    ${program} -domain=${domain} ${logParam} ${action}
	    ;;
    esac
}

# Returns whether a process with a given PID is running
isRunning()# $1 = pid
{
    ps -p $1 1>/dev/null 2>/dev/null
}

# If domain runs, RET is set to its PID.  Returns 0 if domain is
# running, 1 otherwise.
pidOfDomain() # $1 = Domain name
{
    local pidFile
    local pid

    pidFile=${config}/lastPid.${1%*Domain}
    if [ ! -f ${pidFile} ]; then
        return 1
    fi
      
    pid=$(cat ${pidFile})
    if ! isRunning ${pid}; then
        return 1
    fi

    RET=${pid}
    return 0
}

# Returns the name of the log file used by a domain
logOfDomain() # $1 = Domain name
{
    local domain
    
    domain=$1
    case $(getService ${domain}) in
	srm)
	    # Getting the location of the SRM stuff is unfortunately 
            # somewhat messy...
	    if [ -r ${ourHomeDir}/etc/srm_setup.env ] && [ -r ${ourHomeDir}/bin/dcache-srm ]; then
		. ${ourHomeDir}/etc/srm_setup.env
		eval $(grep "export CATALINA_HOME" ${ourHomeDir}/bin/dcache-srm)
		printf "%s" "${CATALINA_HOME}/logs/catalina.out"
	    fi
	    ;;
	*)
	    printf "%s" "${log}/${domain}.log"
	    ;;
    esac
}

# Prints the list of all configured pool domains, including empty
# domains.
getAllPoolDomains() 
{
    if [ -f ${config}/${hostname}.domains ]; then
        
	while read domain; do
            if [ ! -f ${config}/${domain}.poollist ]; then
                printp "Requested pool list file not found (skipped): 
                        ${domainName}.poollist" 1>&2
            else
                printf "%s" "${domain}Domain "
            fi            
	done < ${config}/${hostname}.domains
        
    elif [ -f ${config}/${hostname}.poollist ]; then
        printf "%s" "${hostname}Domain "
    fi
}

# Prints the list of pools in the given pool domains.
getAllPools() # $* = list of domains
{
    for domain in $*; do
        getPoolsInDomain $domain | while read pool path param; do
            printf "%s " $pool
        done
    done
}

# Writes the name of the pool list file for the given pool domain to
# stdout.
getPoolListFile() # $1 = domain name
{
    printf "%s" "${config}/${1%Domain}.poollist"
}

# Writes the poollist file of the given pool domain to stdout. The
# format is 'name directory parameters'. Aborts if the file does not
# exist.
getPoolsInDomain() # $1 = Pool domain 
{
    local poolFile

    poolFile=$(getPoolListFile $1)
    if [ ! -f ${poolFile} ]; then
        printp "Pool file not found: ${poolFile}" 1>&2
        exit 4
    fi
    cat $poolFile
}

getPoolSetting() # #1 = pool path, #2+ = setting
{
    local path
    local key

    path=$1
    shift
    key=$*

    if [ ! -f ${path}/setup ]; then
	printp "Setup file not found in $1" 1>&2
	exit 4
    fi

    #          Comments      Trailing space       Print value
    #          vvvvvvvv      vvvvvvv              vvvvvvvvvvvvvvvvvvvvvvvvvv
    RET=$(sed -n -e 's/#.*$//' -e 's/[ 	]*$//' -e "s/^[ 	]*${key}[ 	]*\(.*\)/\1/p" ${path}/setup)
}

# Extracts the amount of free space in GiB.
getFreeSpace() # $1 = path
{
    local parent
    parent=$(dirname ${1})
    RET=$(df -k "${parent}" | awk 'NR == 2 { if (NF < 4) { getline; x = $3 } else { x = $4 }; printf "%d", x / (1024 * 1024)}')
}

# Converts a string describing some amount of disk space (using an
# optional suffix of k, K, m, M, g, G, t, T, for powers of 1024) to an
# integer number of GiB. 
stringToGiB() # $1 = size
{
    case $1 in
        *k)
            RET=$((${1%?}/(1024*1024)))
            ;;

        *K)
            RET=$((${1%?}/(1024*1024)))
            ;;

        *m)
            RET=$((${1%?}/1024))
            ;;

        *M)
            RET=$((${1%?}/1024))
            ;;

        *g)
            RET=$((${1%?}))
            ;;

        *G)
            RET=$((${1%?}))
            ;;

        *t)
            RET=$((${1%?}*1024))
            ;;

        *T)
            RET=$((${1%?}*1024))
            ;;

        *)
            RET=$(($1/(1024*1024*1024)))
            ;;
    esac
}

# Extracts the size of a pool in GiB.
getSizeOfPool() # $1 = pool path
{
    getPoolSetting ${path} "set max diskspace"
    stringToGiB $RET
}

createPool() # $1 = size in GiB, $2 = path
{
    local size
    local path
    local ds
    local NUMBER_OF_MOVERS
    local set_size
    local set_movers

    stringToGiB $1; size=$RET
    path=$2

    # Path must not exist
    if [ -e ${path} ]; then
	fail 1 "${path} already exists. Operation aborted."
    fi

    # We need to have enough free space
    getFreeSpace ${path}
    ds=$RET

    if [ "${ds}" -lt "${size}" ]; then
	fail 1 "Pool size exceeds available space. ${path} only 
                has ${ds} GiB of free space. Operation aborted."
    fi 

    # Why does node_config contain default values for new pools? That
    # will for sure confuse our users, since they are made to believe
    # they can adjust the number of movers by changing node_config;
    # which is not the case! 
    getConfig NUMBER_OF_MOVERS; NUMBER_OF_MOVERS=$RET

    mkdir -p ${path} ${path}/data ${path}/control || exit 1

    set_size="s:set max diskspace 100g:set max diskspace ${size}g:g"
    set_movers="s:mover set max active 10:mover set max active ${NUMBER_OF_MOVERS}:g"
    sed -e "$set_size" -e "$set_movers" ${config}/setup.temp > ${path}/setup || exit 1

    printp "Created a $size GiB pool in $path. The pool cannot be used
            until it has been added to a domain. Use 'pool add' to do so."\
           "Please note that this script does not set the owner of the
            pool directory. You may need to adjust it."  
}

addPool() # $1 = pool, $2 = path, $3 = domain, $4 = use fqdn, Â£5 = lfs
{
    local pool
    local path
    local domain
    local use_fqdn
    local lfs
    local file
    local param

    pool=$1
    path=$2
    domain=$3
    use_fqdn=$4
    lfs=$5

    sanitisePath $path; path=$RET

    # Check that LFS mode is valid
    if ! contains $lfs none precious hsm volatile transient; then
        fail 2 "Invalid LFS mode." 
    fi

    # Check that path is absolute
    if [ "${path#/}" = "${path}" ]; then
	fail 2 "$path does not appear to be an absolute path. In order
                to add the pool, the absolute path is needed." 
    fi

    # Check that pool exists
    if [ ! -f ${path}/setup ]; then
	fail 1 "No pool found in ${path}. Operation aborted." 
    fi

    # Check that pool is not already a member of a domain
    for d in $(getAllPoolDomains); do
	getPoolsInDomain $d | while read _pool _path _param; do
	    if [ "$path" = "$(sanitisePath $_path)" ]; then
		fail 1 "Pool ${path} already present in ${d}. 
                        Operation aborted." 
	    fi

	    if [ "$pool" = "$_pool" ]; then
		fail 1 "Pool name already used in ${d}. Operation 
                        aborted."
	    fi
	done
	if [ $? -eq 1 ]; then 
	    exit 1
	fi
    done

    # A pool domain must have an ending of 'Domain'
    if [ "${domain%Domain}Domain" != "${domain}" ]; then
	fail 2 "${domain} is not a valid pool domain name, because 
                it does not end with 'Domain'. You may try to use 
                ${domain}Domain."
    fi

    # It must not be used for any other service
    if ! contains $domain $(getAllPoolDomains) ; then
	if contains $domain $(getAllDomains); then
	    fail 1 "${domain} is not a valid pool domain name, because 
                    the domain is already used for other purposes." 
	fi
    fi

    # Create the domain if it doesn't already exist
    file=${config}/${hostname}.domains
    if [ ! -f $file ]; then
	echo "${domain%Domain}" >> $file || exit 1
    elif ! grep "${domain%Domain}" $file > /dev/null; then
	echo "${domain%Domain}" >> $file || exit 1
    fi

    # Determine pool parameters
    param="sticky=allowed recover-space recover-control recover-anyway"
    if [ "$lfs" != "none" ]; then
        param="$param lfs=$lfs"
    fi
    if [ "$use_fqdn" -eq 1 ]; then
	param="$param tag.hostname=$fqdn"
    else
	param="$param tag.hostname=$hostname"
    fi

    # Add pool to domain
    echo "$pool  $path  $param" >> $(getPoolListFile $domain) || exit 1

    # Tell the user what we did
    printp "Added pool ${pool} in ${path} to ${domain}."\
           "The pool will not be operational until the domain has
            been started. Use 'start ${domain}' to start
            the pool domain."
}

removePool() # $1 = pool name
{
    local pool
    local pl

    pool=$1

    # Find the domain containing pool and remove the pool from it
    for domain in $(getAllPoolDomains); do
	getPoolsInDomain $domain | while read _pool _path _param; do
	    if [ "$pool" = "$_pool" ]; then
                # Check if domain is still running
		if pidOfDomain ${domain}; then
		    fail 1 "A pool named $pool was found in the domain 
                            $domain. $domain is still running. Shut it 
                            down before removing the pool from the 
                            configuration. Operation aborted."
		fi
		
	        # Remove pool from pool list file
		pl=$(getPoolListFile $domain)
		sed -i -e "/^${pool}.*/ d" ${pl} || exit 1
		
	        # Disable domain if empty
		if isFileEmpty $pl; then
		    rm $pl || exit 1
		    sed -i -e "/^${domain%Domain}\$/ d" ${config}/${hostname}.domains || exit 1
		    printp "Removed pool ${pool} from ${domain}. ${domain}
                            is now empty and has been removed."
		else
		    printp "Removed pool ${pool} from ${domain}."
		fi

		exit 0
	    fi
	done	
	if [ $? -eq 1 ]; then 
	    exit 1
	fi
    done

    fail 1 "No pool named ${pool} could be found. Operation aborted." 
}

# Searches for executables and exists with an error message if any of
# them are not found on the PATH.
require() # $1 = executable
{
    local tool
    for tool in $*; do 
	if ! type ${tool} > /dev/null 2>&1; then
	    fail 1 "Could not find ${tool}. ${tool} is a required tool."
	fi 
    done
}

# Sets the jmap variable such that it contains the command to invoke
# the jmap utility. Exits if jmap could not be found.
requireJmap()
{
    if [ -n "$jmap" ]; then
        if [ ! -x "$jmap" ]; then
            return 0
        fi
    else
        jmap="$(dirname ${java})/jmap"
        if [ -x "$jmap" ]; then
            return 0
        fi

        if [ -n "$JAVA_HOME" ]; then
            jmap="$JAVA_HOME/bin/jmap"
            if [ -x "$jmap" ]; then
                return 0
            fi
        fi
    fi
    
    fail 1 "Could not find the jmap command, part of the Java 6 JDK.
            This command is required for producing a heap dump. Please
            ensure that either jmap is in the path or update
            dCacheSetup to point to its location."
}

# Read dCacheSetup into variables. Terminates with exit value 1 if the
# file cannot be read or fails basic sanity checks.
readSetup()
{
    if [ -r ${ourHomeDir}/config/dCacheSetup ]; then
        . ${ourHomeDir}/config/dCacheSetup
    else
        fail 1 "${ourHomeDir}/config/dCacheSetup does not exist. You have
                to install and setup dCache before you can use this
                script."
    fi

    # Sanitycheck for serviceLocatorHost
    if [ -z "${serviceLocatorHost}" ] || [ "${serviceLocatorHost}" = "SERVER" ]; then
        fail 1 "The variable 'serviceLocatorHost' in 
                ${ourHomeDir}/config/dCacheSetup has to be set properly."
    fi
    
    # Sanitycheck for java
    if [ -z "${java}" ] || [ ! -x "${java}" ] || ! ${java} -version 2>&1 | egrep -e 'version "1\.[56]' >/dev/null ; then
        fail 1 "The variable 'java' in ${ourHomeDir}/config/dCacheSetup
                has to be set to a Java VM version 5 or 6."
    fi
}

# Check that NODE_TYPE has a valid value.
#
#     admin  : head node
#     custom : custom service definition
#     door   : door only
#     pool   : pool only
#
checkNodeType()
{
    getConfig NODE_TYPE
    case $RET in	
	admin|door|custom|pool)
            # OK
	    ;;
	dummy)
	    # not specified
	    fail 1 "${ourHomeDir}/etc/node_config not configured."
	    ;;
	*)
	    # bad value
	    fail 1 "${ourHomeDir}/etc/node_config missing or not useful."
	    ;;
    esac
}

# Sets the fqdn, hostname, and domainname variables
determineHostName()
{
    case $(uname) in
        SunOS)
            fqdn=$(/usr/lib/mail/sh/check-hostname |cut -d" " -f7)
            ;;
        *)
            fqdn=$(hostname --fqdn)
            ;;
    esac

    hostname=${fqdn%%.*}
    
    if [ "$hostname" = "$fqdn" ]; then
        domainname=
    else
        domainname=${fqdn#*.}
    fi
}

# Parse global options
parseOptions "d" $*
shift $?
ourHomeDir=${opt_d:-/opt/d-cache}

if [ $# -eq 0 ]; then
    usage
fi

# Check prerequisites
require awk df egrep grep sed cat hostname wc dirname basename mount

checkNodeType
readSetup
determineHostName

# Set primary log position
if [ -z "${logArea}" ]; then
    log=${ourHomeDir}/log
    logParam="-logArea=${log}"
else
    log=${logArea}
    logParam=""
fi

case "$1" in
    start)
        shift
        domains=$(expandServiceAndDomainList $*)

        autoMountNameSpace

        for domain in $domains; do
            run $domain start
        done

        touch $LOCK_FILE 2> /dev/null || :
        ;;

    stop)
        shift
        domains=$(expandServiceAndDomainList $*)

        reverse $domains; domains_backward=$RET
        for domain in $domains_backward; do
            run $domain stop
        done

        rm -f $LOCK_FILE
        ;;

    restart)
        shift
        domains=$(expandServiceAndDomainList $*)

        reverse $domains; domains_backward=$RET
        for domain in $domains_backward; do
            run $domain stop
        done

        for domain in $domains; do
            run $domain start
        done
        ;;

    status)
        domains=$(getAllDomains)
        max_width $domains; width=$RET
        format="%-${width}s %-10s%5s %s\n"
        printf "$format" "Domain" "Status" "Pid" "Log file"
        for domain in $domains; do
            if pidOfDomain ${domain}; then
                pid=$RET
                status="running"
            else
                pid=""
                status="stopped"
            fi

            logFile=$(logOfDomain ${domain})
	    if [ ! -f "${logFile}" ]; then
		logFile=""
	    fi
            
            printf "$format" "$domain" "$status" "$pid" "$logFile"
        done
        ;;

    services)
	printf "Service      Domains\n"
	for service in $(getServices); do
	    printf "%-13s%s\n" "${service}" "$(getDomains ${service})"
	done
	;;

    pool)
        shift

        if [ $# -eq 0 ]; then
            usage
        fi

	command=$1
	shift

        case "$command" in
            ls)
                [ $# -gt 0 ] && usage

                domains=$(getAllPoolDomains)
                pools=$(getAllPools $domains)
                max_width $pools; width_1=$RET
                max_width $domains; width_2=$RET
                format="%-${width_1}s %-${width_2}s %-9s %7s%7s %s\n"
                printf "$format" "Pool" "Domain" "LFS" "Size" "Free" "Path"
                for domain in $domains; do
                    getPoolsInDomain $domain | while read pool path param; do
                        lfs=$(echo $param | sed -n -e 's/.*lfs=\([^ ]*\).*/\1/p')
			if [ -f "${path}/setup" ]; then
                            getSizeOfPool $path; size=$RET
			    getFreeSpace $path; free=$RET
                            printf "$format" "$pool" "$domain" "$lfs" "$size" "$free" "$path"
			else
                            printf "$format" "$pool" "$domain" "$lfs" "-" "-" "$path (missing)"
			fi
                    done
                done
                
                echo
                printp "Disk space is measured in GiB. Free space is 
                        reported for the partition containing the pool, 
                        not for the pool itself."
                ;;

	    create)
                [ $# -ne 2 ] && usage

		size=$1
		path=$2

		createPool ${size} ${path}
		;;

            add)
		parseOptions "domain fqdn lfs" $*
		shift $?

                [ $# -ne 2 ] && usage
		pool=$1
		path=$2

		addPool ${pool} ${path} ${opt_domain:-"${hostname}Domain"} ${opt_fqdn:-0} ${opt_lfs:-precious}
		;;

            remove)
                [ $# -ne 1 ] && usage
		pool=$1
		removePool ${pool}
                ;;

	    *)
		usage
		;;
        esac

        ;;

    dump)
        shift

        if [ $# -eq 0 ]; then
            usage 
        fi

	command=$1
	shift

        case "$command" in
            heap)
                [ $# -ne 2 ] && usage

		domain=$1
		file=$2

                requireJmap

                if [ -f ${file} ]; then
                    fail 1 "${file} already exists. Heap not dumped."
                fi

                if ! pidOfDomain ${domain}; then
                    fail 1 "Domain ${domain} is not running."
                fi
                pid=$RET
                
                if ! $jmap -dump:live,format=b,file=${file} ${pid}; then
                    fail 1 "Failed to dump the heap; please consult
                            the previous error message for possible
                            reasons."
                fi

                if [ ! -f ${file} ]; then
                    fail 1 "Failed to dump the heap; please consult
                            the previous error message for possible
                            reasons."
                fi

                printp "The heap of domain ${domain} has been written to 
                        ${file}. Notice that the file might contain 
                        confidential information."
                ;;

            threads)
                domains=$(expandServiceAndDomainList $*)
                for domain in $domains; do
                    if pidOfDomain ${domain}; then
                        if ! kill -s QUIT ${RET}; then
                            fail 1 "Failed to dump stack traces. Likely
                                    the current user does not have the
                                    proper permissions."
                        fi
                    fi
                done

                printp "Stack traces have been written to the log files."
                ;;

	    *)
		usage
		;;
        esac
        ;;

    *)
        usage
        ;;
esac
