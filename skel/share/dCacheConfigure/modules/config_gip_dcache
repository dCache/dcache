# New Yaim Configuration and setup for D-Cache 1.6.6-X 1.7.0, 1.7.1, and 1.8.0
# Maintained by Owen Synge on behalf of Dcache
# Based upon work by 
# M Litmaath, M de Riese, J Mencak, J Novak,L Poncent, O Keeble, L Field and M Aart
# which based thier work upon d-cache configuration adapted 
# from package d-cache-lcg

# GridPP's testing has been very useful

# This script is based upon earlier work by LHC

# Used variables
# Obligatory: DCACHE_ADMIN=admin_host
#             DCACHE_POOLS="pool_node1:[size:]/pool_path1 pool_node2:[size:]/pool_path2"
#             <size> ::= [0-9]*
# Optional:   DCACHE_PNFS_SERVER=pnfs_host
# Optional:   DCACHE_PORT_RANGE="20000,25000"
# Optional:   DCACHE_DOOR_SRM="pool_node1[:port]"
#          Defaults to Admin nodes
# Optional:   DCACHE_DOOR_GSIFTP="pool_node1[:port] pool_node2[:port]"
#          Defaults to Door nodes
# Optional:   DCACHE_DOOR_GSIDCAP="pool_node1[:port] pool_node2[:port]"
#          Defaults to Door nodes
# Optional:   DCACHE_DOOR_DCAP="pool_node1[:port] pool_node2[:port]"
#          Defaults to Door nodes


# Set this to wipe the postgres databases
# Optional:RESET_DCACHE_RDBMS=yes
#
# Set this to reset the PNFS server
# Optional:RESET_DCACHE_PNFS=yes
#
# Set this to reset the D-cache configuration
# Optional:RESET_DCACHE_CONFIGURATION=yes


# Structure of this script

# Yaim utility functions come first in this script, these are placed 
# here to avoid dependacy issues as these are functions that will be 
# Needed by many components, D-Cache in particular makes use of 
# these utilities



# functions starting yaim_query_conf

# This script was always designed as a way to make modification easy
# To this end set up questions are placed at the top of the file. This
# is intended to make porting Yaim to debconf or any other cluster wide 
# management system easy. These functions are queries that could in 
# practice be queries to an interactive installer or a cluster 
# management system

#
# functions starting yaim_state

# These functions are to establish the state of the install and direct 
# what components are to be installed. They do not change the state 
# of uninstalled/installed components


# functions starting yaim_config

# Start of yaim query functions


yaim_query_conf_infoprovider_system()
{
  # Returns 0 when node is not LCG info system node
  # Returns 1 when node is LCG info system node
  local result
  local thishost
  local hostspec
  result=0
  if [ -z "$DCACHE_DOOR_LDAP" ] ; then
    yaim_query_conf_node_dcache_admin
    result=$?
  else
    thishost=`hostname -f`
    hostspec=$(echo "$DCACHE_DOOR_LDAP" | grep -o "$thishost[^ ]*")
    if [ "x$hostspec" != "x" ]; then
      result=1
    fi
  fi
  return ${result}
}

yaim_query_conf_info_system()
{
  # Returns 0 when node is not LCG info system node
  # Returns 1 when node is LCG info system node
  local result
  local thishost
  local hostspec
  result=0
  if [ -z "$DCACHE_PROVIDER_INFO" ] ; then
    yaim_query_conf_node_dcache_admin
    result=$?
  else
    thishost=`hostname -f`
    hostspec=$(echo "$DCACHE_PROVIDER_INFO" | grep -o "$thishost[^ ]*")
    if [ "x$hostspec" != "x" ]; then
      result=1
    fi
  fi
  return ${result}
}


yaim_query_conf_web_system()
{
  # Returns 0 when node is not LCG info system node
  # Returns 1 when node is LCG info system node
  local result
  local thishost
  local hostspec
  result=0
  if [ -z "$DCACHE_PROVIDER_WEB" ] ; then
    if [ -n "$DCACHE_PROVIDER_INFO" ] ; then
      yaim_query_conf_info_system
      result=$?    
    else
      yaim_query_conf_node_dcache_admin
      result=$?
    fi
  else
    thishost=`hostname -f`
    hostspec=$(echo "$DCACHE_PROVIDER_WEB" | grep -o "$thishost[^ ]*")
    if [ "x$hostspec" != "x" ]; then
      result=1
    fi
  fi
  return ${result}
}





yaim_query_conf_bdii_port()
{
RET="2135"
if [ -f "/etc/init.d/bdii" ] ; then
RET="2170"
fi
}




yaim_query_conf_file_path_info_config_file()
{
local allPotFiles
local potFile
RET=""
allPotFiles="/opt/glite/etc/gip/glite-info-generic.conf /opt/lcg/etc/lcg-info-generic.conf"
for potFile in ${allPotFiles}
do
  if [ "$RET" == "" ] ; then
    if [ -f "$potFile" ] ; then
      RET=$potFile
    fi 
  fi
done
}

yaim_query_conf_file_path_info_config_file_value()
{
  key=$1
  if [ "X${key}" == "X" ] ; then
    yaimlog ERROR "called function yaim_query_conf_file_path_info_config_file_value without a parameter"
  
    RET=""
    return 0
  fi
  yaim_query_conf_file_path_info_config_file
  config_file_rc=$?
  gipconf=$RET  
    if [ -f "$gipconf" ] ; then
      yaim_config_file_get_value $gipconf "$key " 
      #yaimlog DEBUG "yaim_config_file_get_value $gipconf $key"
      output=${RET##" "}
      #yaimlog DEBUG "output=$output"
      if [ "X" != "X${output}" ] ; then
        RET=${output}
      fi
    fi
    
}

yaim_query_conf_file_path_info_template_static_se()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_info_template_static_se start"
  local defaultvalue
  local gipconf
  local static_dir
  defaultvalue="/opt/lcg/var/gip/tmp/lcg-info-static-se.conf"
  yaim_query_conf_file_path_info_config_file_value temp_dir
  static_dir=${RET##" "}
  #yaimlog DEBUG "Setting static_dir=$static_dir"
  
  if [ -d "$static_dir" ] ; then
    RET=${static_dir}/lcg-info-static-se.conf
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_file_path_info_template_static_se stop"
}


yaim_query_conf_file_path_info_dse_conf()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_info_dse_conf start"
  local defaultvalue
  local static_dir  
  defaultvalue=/opt/lcg/var/gip/tmp/lcg-info-static-dse.conf
  yaim_query_conf_file_path_info_config_file_value temp_dir
  static_dir=${RET##" "}  
  if [ -d "$static_dir" ] ; then
    RET=${static_dir}/lcg-info-static-dse.conf
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_file_path_info_dse_conf stop"

}

yaim_query_conf_path_info_plugin()
{
  yaimlog DEBUG "function yaim_query_conf_path_info_plugin start"
  local defaultvalue
  local plug_dir
  defaultvalue=/opt/lcg/var/gip/plugin/
  yaim_query_conf_file_path_info_config_file_value plugin_dir
  plug_dir=${RET##" "}  
  if [ -d "$plug_dir" ] ; then
    RET=${plug_dir}/
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_path_info_plugin stop"
}


yaim_query_conf_file_path_plugin_old()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_old start"
  local defaultvalue
  local plug_dir
  defaultvalue=/opt/lcg/var/gip/plugin/lcg-info-dynamic-se
  yaim_query_conf_file_path_info_config_file_value plugin_dir
  plug_dir=${RET##" "}  
  if [ -d "$plug_dir" ] ; then
    RET=${plug_dir}/lcg-info-dynamic-se
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_old stop"
}
yaim_query_conf_file_path_plugin_new()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_new start"
  local defaultvalue
  local plug_dir
  defaultvalue=/opt/lcg/var/gip/plugin/infoDynamicSE-plugin-dcache
  yaim_query_conf_file_path_info_config_file_value plugin_dir
  plug_dir=${RET##" "} 
  if [ -d "$plug_dir" ] ; then
    RET=${plug_dir}/infoDynamicSE-plugin-dcache
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_new stop"
}


yaim_query_file_path_static_ldif()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_new start"
  local defaultvalue
  local plug_dir
  defaultvalue=/opt/lcg/var/gip/ldif/static-file-SE.ldif
  yaim_query_conf_file_path_info_config_file_value static_dir
  plug_dir=${RET##" "} 
  if [ -d "$plug_dir" ] ; then
    RET=${plug_dir}/static-file-SE.ldif
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_new stop"
}

yaim_query_file_path_static_ldif_service()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_new start"
  local defaultvalue
  local plug_dir
  defaultvalue=/opt/lcg/var/gip/ldif/static-file-dSE.ldif
  yaim_query_conf_file_path_info_config_file_value static_dir
  plug_dir=${RET##" "} 
  if [ -d "$plug_dir" ] ; then
    RET=${plug_dir}/static-file-dSE.ldif
  else
    RET=$defaultvalue
  fi
  yaimlog DEBUG "function yaim_query_conf_file_path_plugin_new stop"
}

yaim_query_conf_file_path_info_template()
{
  yaimlog DEBUG "function yaim_query_conf_file_path_info_template start"
  RET="/opt/lcg/var/gip/tmp/lcg-info-dynamic-se.ldif.4065"
  yaimlog DEBUG "function yaim_query_conf_file_path_info_template stop"
}
yaim_query_path_info_static_create()
{
local allPotFiles
local potFile
RET=""
allPotFiles="/opt/glite/sbin/glite-info-static-create /opt/lcg/sbin/lcg-info-static-create"
for potFile in ${allPotFiles}
do
  if [ -f "$potFile" ] ; then
    RET=$potFile
    return 1
  fi
done
return 0
}

yaim_query_path_GlueSE_template()
{
local allPotFiles
local potFile
RET=""
allPotFiles="/opt/glite/etc/GlueSE.template /opt/lcg/etc/GlueSE.template"
for potFile in ${allPotFiles}
do
  if [ -f "$potFile" ] ; then
    RET=$potFile
    return 1
  fi
done
return 0
}


yaim_query_path_GlueService_template()
{
local allPotFiles
local potFile
RET=""
allPotFiles="/opt/glite/etc/GlueService.template /opt/lcg/etc/GlueService.template"
for potFile in ${allPotFiles}
do
  if [ -f "$potFile" ] ; then
    RET=$potFile
    return 1
  fi
done
return 0
}


yaim_config_info_template_static_set() 
{
    yaimlog DEBUG "function yaim_config_info_template_static_set start"
    local dcap_door_node_port_list
    local file2update
    local GlueDoor
    local GlueForeignKey
    local GlueInformationServiceHost
    local GlueInformationServicePort
    local GlueSAPathVo
    local GlueSAPolicyFileLifeTimeVo
    local GlueSAPolicyMaxDataVo
    local GlueSAPolicyMaxFileSizeVo
    local GlueSAPolicyMaxNumFilesVo
    local GlueSAPolicyMaxPinDurationVo
    local GlueSAPolicyMinFileSizeVo
    local GlueSAPolicyQuotaVo
    local GlueSARootVo
    local GlueSAStateAvailableSpaceVo
    local GlueSAStateUsedSpaceVo    
    local GlueSATypeVo
    local GlueSEAccessProtocolEndpointHostdcap
    local GlueSEAccessProtocolEndpointHostGsidcap
    local GlueSEAccessProtocolEndpointHostGsiFtp
    local GlueSEAccessProtocolEndpointHostSrm
    local GlueSEAccessProtocolPort
    local GlueSEArchitecture
    local GlueSEControlProtocolLocalID
    local GlueSEName
    local GlueSEPort
    local GlueSESizeFree
    local GlueSESizeTotal
    local GlueSEUniqueID
    local gsidcap_door_node_port_list
    local gsiftp_door_node_port_list
    local srm_door_node_port_list
    local srm_door_port
    
    yaim_query_conf_file_path_info_template_static_se
    file2update=$RET
    if [ -z "$file2update" ] ; then
        yaimlog ABORT "File to update is not set!"
	exit 12
    fi
    yaim_query_conf_dcache_srm_door_node_port_list
    srm_door_node_port_list=$RET
    
    yaim_query_conf_node_srm_door_port
    srm_door_port=$RET
    GlueSEName="dcache@${DCACHE_ADMIN}:SRM"
    GlueSEUniqueID=${DCACHE_ADMIN}
    GlueSEPort="2811"
    GlueSESizeTotal="1000000"
    GlueSESizeFree="0"
    GlueSEArchitecture=${SE_ARCH}
    GlueForeignKey="GlueSiteUniqueID=${SITE_NAME}"
    
    GlueInformationServiceHost=`hostname -f`
    yaim_query_conf_bdii_port
    GlueInformationServicePort=$RET
    

 
echo >  $file2update

cat <<EOF>> $file2update
dn: GlueSEUniqueID=${GlueSEUniqueID}
GlueSEName: ${GlueSEName}
GlueSEPort: ${GlueSEPort}
GlueSESizeTotal: ${GlueSESizeTotal}
GlueSESizeFree: ${GlueSESizeFree}
GlueSEArchitecture: ${GlueSEArchitecture}
GlueSEImplementationName: dCache
GlueSEImplementationVersion: 1.8.0
GlueSETotalNearlineSize: 0
GlueSETotalOnlineSize: 0
GlueSEUsedOnlineSize: 0
GlueSEUsedNearlineSize: 0
GlueInformationServiceURL: ldap://${GlueInformationServiceHost}:${GlueInformationServicePort}/mds-vo-name=local,o=grid
GlueForeignKey: GlueSiteUniqueID=${SITE_NAME}
EOF



echo >> $file2update
yaim_query_conf_file_path_info_dse_conf
secondfile2update=$RET


for SRMDoor in $(echo ${srm_door_node_port_list})
do
GlueSEAccessProtocolEndpointHostSrm=$(echo ${SRMDoor} | cut -d: -f1 -s)
GlueSEAccessProtocolEndpointPortSrm=$(echo ${SRMDoor} | cut -d: -f2 -s)
    cat <<EOF> $secondfile2update
dn: GlueServiceUniqueID=httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv2,GlueSEUniqueID=${GlueSEUniqueID}
GlueServiceUniqueID: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv2
GlueForeignKey: ${GlueForeignKey}
GlueServiceVersion: 2.2.0
GlueServiceName: ${SITE_NAME}-srm
GlueServiceType: SRM
GlueServiceEndpoint: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv2
GlueServiceURI: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv2
GlueServiceAccessPointURL: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv2
GlueServiceStatusInfo: No Problems
GlueServiceWSDL: unset
GlueServiceSemantics: unset
GlueServiceStartTime: 1970-01-01T00:00:00Z
GlueServiceOwner: LCG
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
for GlueSESupportedVo in `echo ${VOS}`
do
  echo GlueServiceAccessControlRule: $GlueSESupportedVo >> $secondfile2update
done

cat <<EOF >> $secondfile2update
GlueServiceInformationServiceURL: MDS2GRIS:ldap://${BDII_HOST}:2170/mds-vo-name=${SITE_NAME},o=grid
GlueServiceStatus: OK
EOF


done



for SRMDoor in $(echo ${srm_door_node_port_list})
do
GlueSEAccessProtocolEndpointHostSrm=$(echo ${SRMDoor} | cut -d: -f1 -s)
GlueSEAccessProtocolEndpointPortSrm=$(echo ${SRMDoor} | cut -d: -f2 -s)
    cat <<EOF>> $secondfile2update
dn: GlueServiceUniqueID=httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv1,GlueSEUniqueID=${GlueSEUniqueID}
GlueServiceUniqueID: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv1
GlueForeignKey: ${GlueForeignKey}
GlueServiceVersion: 1.1.0
GlueServiceName: ${SITE_NAME}-srm
GlueServiceType: SRM
GlueServiceEndpoint: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv1
GlueServiceURI: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv1
GlueServiceAccessPointURL: httpg://${GlueSEAccessProtocolEndpointHostSrm}:${srm_door_port}/srm/managerv1
GlueServiceStatusInfo: No Problems
GlueServiceWSDL: unset
GlueServiceSemantics: unset
GlueServiceStartTime: 1970-01-01T00:00:00Z
GlueServiceOwner: LCG
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
for GlueSESupportedVo in `echo ${VOS}`
do
  echo GlueServiceAccessControlRule: $GlueSESupportedVo >> $secondfile2update
done

cat <<EOF >> $secondfile2update
GlueServiceInformationServiceURL: MDS2GRIS:ldap://${BDII_HOST}:2170/mds-vo-name=${SITE_NAME},o=grid
GlueServiceStatus: OK
EOF


done


echo >> $file2update


# Now add Protocols

#SrmV2 start


for GlueDoor in `echo ${srm_door_node_port_list}`
do
GlueSEAccessProtocolEndpointHostSrm=$(echo ${GlueDoor} | cut -d: -f1)
GlueSEAccessProtocolEndpointPortSrm=$(echo ${GlueDoor} | cut -d: -f2)
cat <<EOF>> $file2update
dn: GlueSEControlProtocolLocalID=srm_v2@${GlueSEAccessProtocolEndpointHostSrm},GlueSEUniqueID=${GlueSEUniqueID}
GlueSEControlProtocolType: SRM
GlueSEControlProtocolEndpoint:httpg://${GlueSEAccessProtocolEndpointHostSrm}:${GlueSEAccessProtocolEndpointPortSrm}/srm/managerv2
GlueSEControlProtocolCapability: space allocation
GlueSEControlProtocolCapability: space management
GlueSEControlProtocolVersion: 2.2.0
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
echo >> $file2update
done
#SrmV2 end

#SrmV1 start


for GlueDoor in `echo ${srm_door_node_port_list}`
do
GlueSEAccessProtocolEndpointHostSrm=$(echo ${GlueDoor} | cut -d: -f1)
GlueSEAccessProtocolEndpointPortSrm=$(echo ${GlueDoor} | cut -d: -f2)
cat <<EOF>> $file2update
dn: GlueSEControlProtocolLocalID=srm_v1@${GlueSEAccessProtocolEndpointHostSrm},GlueSEUniqueID=${GlueSEUniqueID}
GlueSEControlProtocolType: SRM
GlueSEControlProtocolEndpoint:httpg://${GlueSEAccessProtocolEndpointHostSrm}:${GlueSEAccessProtocolEndpointPortSrm}/srm/managerv1
GlueSEControlProtocolCapability: space allocation
GlueSEControlProtocolCapability: space management
GlueSEControlProtocolVersion: 1.1.0
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
echo >> $file2update
done
#SrmV1 end


#GsiFTP start
# This section is commented out as it is not commonly used 
# and not quite complete. The failings are I think that the 
# service discorary is not done through LDAP for GSIFTP so 
# does not have a way currently of doing things wihtout 
# murging all GSIFTP doors into one section

yaim_query_conf_dcache_gsiftp_door_node_port_list
gsiftp_door_node_port_list=$RET
for GlueDoor in `echo ${gsiftp_door_node_port_list}`
do
GlueSEAccessProtocolEndpointHostGsiFtp=$(echo ${GlueDoor} | cut -d: -f1)
GlueSEAccessProtocolPort=$(echo ${GlueDoor} | cut -d: -f2)

cat <<EOF>> $file2update
dn: GlueSEAccessProtocolLocalID=gsiftp@${GlueSEAccessProtocolEndpointHostGsiFtp},GlueSEUniqueID=${GlueSEUniqueID}
GlueSEAccessProtocolType: gsiftp
GlueSEAccessProtocolEndpoint:gsiftp://${GlueSEAccessProtocolEndpointHostGsiFtp}:${GlueSEAccessProtocolPort}
GlueSEAccessProtocolCapability: file transfer
GlueSEAccessProtocolVersion: 1.0
GlueSEAccessProtocolMaxStreams: 20
GlueSEAccessProtocolPort: ${GlueSEAccessProtocolPort}
GlueSEAccessProtocolSupportedSecurity: GSI
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
echo >> $file2update

cat <<EOF>> $file2update
dn: GlueSEAccessProtocolLocalID=gridftp@${GlueSEAccessProtocolEndpointHostGsiFtp},GlueSEUniqueID=${GlueSEUniqueID}
GlueSEAccessProtocolType: gridftp
GlueSEAccessProtocolEndpoint:gridftp://${GlueSEAccessProtocolEndpointHostGsiFtp}:${GlueSEAccessProtocolPort}
GlueSEAccessProtocolCapability: file transfer
GlueSEAccessProtocolVersion: 1.0
GlueSEAccessProtocolMaxStreams: 20
GlueSEAccessProtocolPort: ${GlueSEAccessProtocolPort}
GlueSEAccessProtocolSupportedSecurity: GSI
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
echo >> $file2update


done
#GsiFTP end

#GsiDcap start
yaim_query_conf_dcache_gsidcap_door_node_port_list
gsidcap_door_node_port_list=$RET
for GlueDoor in `echo ${gsidcap_door_node_port_list}`
do
GlueSEAccessProtocolEndpointHostGsidcap=$(echo ${GlueDoor} | cut -d: -f1)
GlueSEAccessProtocolPort=$(echo ${GlueDoor} | cut -d: -f2)

cat <<EOF>> $file2update
dn: GlueSEAccessProtocolLocalID=gsidcap@${GlueSEAccessProtocolEndpointHostGsidcap},GlueSEUniqueID=${GlueSEUniqueID}
GlueSEAccessProtocolType: gsidcap
GlueSEAccessProtocolEndpoint:gsidcap://${GlueSEAccessProtocolEndpointHostGsidcap}:${GlueSEAccessProtocolPort}
GlueSEAccessProtocolCapability: file transfer
GlueSEAccessProtocolVersion: 1.0
GlueSEAccessProtocolMaxStreams: 1
GlueSEAccessProtocolPort: ${GlueSEAccessProtocolPort}
GlueSEAccessProtocolSupportedSecurity: GSI
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
echo >> $file2update
done
#Gsidcap end



#Vo Start

for GlueSESupportedVo in `echo ${VOS}`
do
config_dcache_pnfs_vo_dir_get
GlueSARootVo="${GlueSESupportedVo}:$RET/${GlueSESupportedVo}"
GlueSAPathVo="$RET/${GlueSESupportedVo}"
GlueSATypeVo="volatile"
GlueSAPolicyMaxFileSizeVo="10000"
GlueSAPolicyMinFileSizeVo="1"
GlueSAPolicyMaxDataVo="100"
GlueSAPolicyMaxNumFilesVo="999999"
GlueSAPolicyMaxPinDurationVo="10"
GlueSAPolicyQuotaVo=0
GlueSAPolicyFileLifeTimeVo="volatile"
GlueSAStateAvailableSpaceVo="0"
GlueSAStateUsedSpaceVo="999999"
cat <<EOF>> $file2update
dn: GlueSALocalID=${GlueSESupportedVo},GlueSEUniqueID=${GlueSEUniqueID}
GlueSARoot: ${GlueSARootVo}
GlueSAPath: ${GlueSAPathVo}
GlueSAType: ${GlueSATypeVo}
GlueSATotalOnlineSize: 0
GlueSAUsedOnlineSize: 0
GlueSAFreeOnlineSize: 0
GlueSAReservedOnlineSize: 0
GlueSATotalNearlineSize: 0
GlueSAUsedNearlineSize: 0
GlueSAFreeNearlineSize: 0
GlueSAReservedNearlineSize: 0
GlueSARetentionPolicy: replica
GlueSAAccessLatency: online
GlueSAExpirationMode: neverExpire
GlueSACapability: ${GlueSESupportedVo}
GlueSAPolicyMaxFileSize: ${GlueSAPolicyMaxFileSizeVo}
GlueSAPolicyMinFileSize: ${GlueSAPolicyMinFileSizeVo}
GlueSAPolicyMaxData: ${GlueSAPolicyMaxDataVo}
GlueSAPolicyMaxNumFiles: ${GlueSAPolicyMaxNumFilesVo}
GlueSAPolicyMaxPinDuration: ${GlueSAPolicyMaxPinDurationVo}
GlueSAPolicyQuota: ${GlueSAPolicyQuotaVo}
GlueSAPolicyFileLifeTime: ${GlueSAPolicyFileLifeTimeVo}
GlueSAStateAvailableSpace: ${GlueSAStateAvailableSpaceVo}
GlueSEAccessProtocolSupportedSecurity: gsi
GlueSAStateUsedSpace: ${GlueSAStateUsedSpaceVo}
GlueSAAccessControlBaseRule: ${GlueSESupportedVo}
GlueSAAccessControlBaseRule: VO:${GlueSESupportedVo}
GlueChunkKey: GlueSEUniqueID=${GlueSEUniqueID}
EOF
echo >> $file2update
done


#echo > $file2update

yaimlog DEBUG "function yaim_config_info_template_static_set stop"
}


yaim_config_info_link()
{
yaimlog DEBUG "function yaim_config_info_link start"
local old_plugin
local new_pluggin

yaim_query_conf_file_path_plugin_old
old_plugin=$RET
yaim_query_conf_file_path_plugin_new
new_pluggin=$RET
if [ -f "$old_plugin" ] ;  then
  rm $old_plugin
fi
if [ ! -h '$new_pluggin' ] ; then
  if [ -e "$new_pluggin" ] ;  then
    rm $new_pluggin
  fi
  yaim_query_conf_path_info_plugin
  infoplugin=$RET
  yaimlog INFO "symlinked $infoplugin to /opt/d-cache/jobs/infoDynamicSE-plugin-dcache"
  ln -s /opt/d-cache/jobs/infoDynamicSE-plugin-dcache $infoplugin
fi
yaimlog DEBUG "function yaim_config_info_link stop"
}

yaim_config_info_system_break_old()
{
    #Remove /opt/lcg/var/gip/plugin/lcg-info-dynamic-se 
    #and the dynamic file /opt/lcg/var/gip/tmp/lcg-info-dynamic-se.ldif.4065 
    #to stop old LCG dynamic information provider. Good idea 
    #to restart globus-mds.
    local lcgInfoPluggin
    local lcgInfoTemplate
    yaim_query_conf_file_path_plugin_old
    lcgInfoPluggin=$RET
    yaim_query_conf_file_path_info_template
    lcgInfoTemplate=$RET
    if [ -f "${lcgInfoPluggin}" ] ; then
        rm ${lcgInfoPluggin}
    fi
    if [ -f "${lcgInfoTemplate}" ] ; then
        rm ${lcgInfoTemplate}
    fi
}

yaim_config_info_provide()
{
local info_static_create
local info_static_se
local info_GlueSE_template
local static_ldif
yaimlog DEBUG "function yaim_config_info_provide start"
yaim_query_path_info_static_create
info_static_create=$RET
yaim_query_conf_file_path_info_template_static_se
info_static_se=$RET
yaim_query_path_GlueSE_template
info_GlueSE_template=$RET
yaim_query_file_path_static_ldif
static_ldif=$RET
yaim_query_conf_file_path_info_dse_conf
info_static_service=$RET
yaim_query_path_GlueService_template
info_GlueService_template=$RET
yaim_query_file_path_static_ldif_service
static_ldif_service=$RET
yaimlog DEBUG "Running ${info_static_create} \
  -c ${info_static_se}  \
  -t ${info_GlueSE_template} to $static_ldif"
${info_static_create} \
  -c ${info_static_se}  \
  -t ${info_GlueSE_template} > $static_ldif
yaimlog DEBUG "Created file $static_ldif"
yaimlog DEBUG "Running ${info_static_create} \
  -c ${info_static_service} \
  -t ${info_GlueService_template} to \
  $static_ldif_service"
${info_static_create} \
-c ${info_static_service} \
    -t ${info_GlueService_template} > ${static_ldif_service}
yaimlog DEBUG "Created file $static_ldif_service"


yaimlog DEBUG "function yaim_config_info_provide stop"
}

yaim_config_info_restart()
{
yaimlog DEBUG "function yaim_config_info_restart start"
if [ -f /etc/init.d/globus-mds ] ; then
  /etc/init.d/globus-mds restart
fi
if [ -f /etc/init.d/bdii ] ; then
  /etc/init.d/bdii restart
fi


yaimlog DEBUG "function yaim_config_info_provideyaim_config_info_restart stop"
}

yaim_state_info_setup()
{
yaimlog DEBUG "function yaim_state_info_setup start"
local SOURCE
local gipstatic
local DESTINATION
yaim_query_conf_file_path_info_dse_conf
dseconf=$RET
SOURCE=/opt/d-cache/config/dCacheSetup
yaim_query_file_path_static_ldif
gipstatic=$RET


yaim_config_file_update_prepare $SOURCE
DESTINATION=$RET
yaim_config_file_set_value "$DESTINATION" infoProviderStaticFile "$gipstatic"
yaim_config_file_update_done $SOURCE
if [ $? == 1 ] ; then 
    yaim_state_service_restart_needed core
    yaim_config_info_restart
fi
if [ -f '$dseconf' ] ;  then
  rm $dseconf
fi
yaimlog DEBUG "function yaim_state_info_setup stop"
}


yaim_config_info_system()
{
  yaimlog DEBUG "function yaim_config_info_system start"
  #yaim_config_info_template_static_set
  #yaim_config_info_link
  #yaim_config_info_system_break_old
  #yaim_config_info_provide
  yaim_config_info_system_break_old 
  #yaim_config_info_restart
  yaim_state_info_setup
  yaim_config_info_link
  yaim_config_info_template_static_set
  yaim_config_info_provide
  yaim_config_info_restart
  yaimlog DEBUG "function yaim_config_info_system stop"
}
config_gip_dcache_check()
{
  return 0
}

config_gip_check_users_exist()
{
  yaimlog DEBUG "function config_gip_check_users_exist start"
  local allisGood
  local foundUid
  allisGood=0
  foundUid=$(id -u edguser 2> /dev/null)
  if [ "X" == "X${foundUid}" ] ; then
    yaimlog ERROR "User edguser not found."
    allisGood=1
  fi
  foundGid=$(id -g edguser 2> /dev/null)
  if [ "X" == "X${foundGid}" ] ; then
    yaimlog ERROR "Group edguser not found."
    allisGood=1
  fi
  foundGid=$(id -u edginfo 2> /dev/null)
  if [ "X" == "X${foundGid}" ] ; then
    yaimlog ERROR "User edginfo not found."
    allisGood=1
  fi
  
  if [ "${allisGood}" != "0" ] ; then
    yaimlog ERROR "Exiting due to required users and groups missing."
    exit 4
  fi
  yaimlog DEBUG "function config_gip_check_users_exist stop"
}


config_gip_dcache_run()
{
  yaimlog DEBUG "function yaim_config_info_system start"
  yaim_query_conf_infoprovider_system
  rcisvd=$?  
  if [ "${rcisvd}" == "1" ] ; then
    # Use new info system and disable the old info system
    config_gip_check_users_exist
    config_bdii_only
    config_gip_only
    yaim_config_info_system
  fi
  yaimlog DEBUG "function yaim_config_info_system end"
}



config_gip_dcache()
{
  if [ "yes" == "$DESYOVERRIDE" ] ; then
    return 0
  fi
}
